---
title: "M01w02 - Grid027"
datePublished: Tue Jun 17 2025 04:09:07 GMT+0000 (Coordinated Universal Time)
cuid: cmc007hmg000302l73pv54tes
slug: m01w02-grid027

---

# **M01W02 - List**

## 1: Phân Tích Nền Tảng về List trong Python: Một Cấu Trúc Dữ Liệu Cốt Lõi

### 1.1. Định nghĩa List

Trong hệ sinh thái của ngôn ngữ lập trình Python, `List` là một trong những cấu trúc dữ liệu cơ bản và được sử dụng rộng rãi nhất. Tài liệu giảng dạy giới thiệu `List` một cách trực quan, mô tả nó như một "container có thể chứa các phần tử" và là một công cụ "được sử dụng để lưu trữ nhiều mục trong một biến duy nhất". Cú pháp để khởi tạo một `List` cũng được trình bày rõ ràng: `list_name = [element-1,..., element-n]`, trong đó các phần tử được đặt trong dấu ngoặc vuông và phân tách bởi dấu phẩy.

Mặc dù phép ẩn dụ "container" hay "hộp chứa" rất hiệu quả trong việc giúp người mới bắt đầu hình dung về `List`, một phân tích chuyên sâu hơn đòi hỏi phải làm rõ bản chất kỹ thuật của nó. Về mặt triển khai, `List` trong Python được xây dựng dựa trên cấu trúc dữ liệu **mảng động (dynamic array)**. Hiểu rõ về cơ chế hoạt động của mảng động là chìa khóa để giải thích các đặc tính về hiệu năng của `List`, một khía cạnh quan trọng không được đề cập tường minh trong tài liệu gốc.

Việc triển khai `List` dưới dạng mảng động mang lại những hệ quả trực tiếp về hiệu năng của các thao tác khác nhau:

* **Truy cập phần tử theo chỉ mục (Indexing):** Mảng động lưu trữ các phần tử trong một khối bộ nhớ liền kề. Điều này cho phép thực hiện thao tác truy cập phần tử theo chỉ mục, ví dụ `data`, với tốc độ cực kỳ nhanh. Vị trí bộ nhớ của phần tử có thể được tính toán trực tiếp thông qua một phép toán đơn giản: base\_address+index×element\_size. Do đó, độ phức tạp thời gian của thao tác này là hằng số, hay O(1).
    
* **Thêm và xóa phần tử ở đầu hoặc giữa danh sách:** Ngược lại với việc truy cập, việc thêm một phần tử vào đầu danh sách (ví dụ: `data.insert(0, 4)` ) hoặc vào giữa là một thao tác tốn kém. Để chèn một phần tử vào chỉ mục 0, tất cả các phần tử khác trong mảng phải được dịch chuyển sang phải một vị trí để tạo ra không gian trống. Thao tác này đòi hỏi một số lượng phép dịch chuyển tỷ lệ thuận với số lượng phần tử trong danh sách. Do đó, độ phức tạp thời gian của nó là tuyến tính, hay O(n), với n là số lượng phần tử. Tương tự, việc xóa một phần tử cũng đòi hỏi phải dịch chuyển các phần tử phía sau để lấp đầy khoảng trống, dẫn đến độ phức tạp O(n).
    
* **Thêm phần tử vào cuối danh sách (Appending):** Thao tác thêm phần tử vào cuối danh sách bằng phương thức `.append()` thường rất nhanh. Độ phức tạp thời gian của nó được gọi là **thời gian trừ dần (amortized) O(1)**. Điều này có được là do mảng động thường cấp phát trước một lượng bộ nhớ dự phòng. Khi các phần tử mới được thêm vào, chúng chỉ cần được đặt vào không gian đã được cấp phát sẵn này. Chỉ khi không gian dự phòng này đã đầy, mảng mới cần thực hiện một thao tác cấp phát lại bộ nhớ (resize) tốn kém hơn: tạo một mảng mới lớn hơn, sao chép tất cả các phần tử từ mảng cũ sang mảng mới, và sau đó giải phóng mảng cũ. Tuy nhiên, vì thao tác resize này không xảy ra thường xuyên, chi phí của nó khi được phân bổ đều cho tất cả các thao tác `.append()` trước đó sẽ trở nên không đáng kể, dẫn đến độ phức tạp trung bình là O(1).
    

Sự khác biệt về hiệu năng giữa `.append()` (thường là O(1)) và `.insert()` (O(n)) là một hệ quả trực tiếp của cấu trúc mảng động bên dưới, và là một kiến thức nền tảng để viết mã Python hiệu quả và tối ưu.

### 1.2. Giải Cấu Trúc các Đặc Tính Cốt Lõi

Tài liệu tại trang 11 liệt kê bốn đặc tính cơ bản của `List`: có thứ tự (Ordered), có thể lập chỉ mục (Indexable), không đồng nhất (Heterogeneous), và cho phép các phần tử trùng lặp (Duplicates). Các đặc tính này không phải là những thuộc tính độc lập mà có mối quan hệ nhân quả và phản ánh các quyết định thiết kế cốt lõi của ngôn ngữ Python.

* **Mối quan hệ giữa "Ordered" và "Indexable":** Đặc tính "Ordered" có nghĩa là các phần tử trong `List` duy trì một trình tự ổn định; thứ tự mà các phần tử được thêm vào sẽ được giữ nguyên. Đây chính là tiền đề logic cho phép đặc tính "Indexable" tồn tại. Bởi vì các phần tử có một vị trí xác định và không đổi trong chuỗi, chúng ta mới có thể truy cập chúng một cách đáng tin cậy thông qua một chỉ mục (index) như `data` hay `data[-1]`. Một cấu trúc dữ liệu không có thứ tự (ví dụ như `Set` trong Python) sẽ không thể được lập chỉ mục một cách có ý nghĩa. Do đó, "Indexable" là hệ quả trực tiếp của "Ordered".
    
* **"Heterogeneous" là hệ quả của Kiểu Động (Dynamic Typing):** Đặc tính "Heterogeneous" cho phép một `List` duy nhất chứa các phần tử thuộc nhiều kiểu dữ liệu khác nhau, ví dụ: `mixed_list =`. Khả năng này là một hệ quả trực tiếp từ bản chất của Python là một ngôn ngữ có kiểu động (dynamically-typed). Trong Python, các biến là tên tham chiếu đến các đối tượng, và một `List` thực chất là một mảng các con trỏ trỏ đến các đối tượng này. Vì các đối tượng có thể thuộc bất kỳ kiểu nào, `List` có thể chứa các tham chiếu đến các đối tượng thuộc các kiểu khác nhau. Điều này hoàn toàn trái ngược với các ngôn ngữ có kiểu tĩnh (statically-typed) như C++ hay Java, nơi một mảng thường phải chứa các phần tử đồng nhất về kiểu. Sự linh hoạt này của Python đi kèm với một chi phí hiệu năng tiềm ẩn (liên quan đến việc đóng/mở hộp giá trị - boxing/unboxing), nhưng lại mang lại sự tiện lợi lớn trong lập trình.
    
* **"Mutable" là nền tảng của các Thao tác Tại Chỗ (In-Place):** Tài liệu minh họa rằng `List` là một cấu trúc dữ liệu **có thể thay đổi (mutable)** thông qua các ví dụ như gán lại giá trị cho một phần tử: `data = 4`. Đặc tính này là nền tảng cho sự tồn tại của một loạt các phương thức được gọi là "thao tác tại chỗ" (in-place operations), bao gồm `.append()`, `.remove()`, `.sort()`, `.reverse()`. Các phương thức này sửa đổi trực tiếp đối tượng `List` gốc mà không cần tạo ra một đối tượng mới. Đây là một khái niệm cơ bản phân biệt `List` với các kiểu dữ liệu bất biến (immutable) như `tuple` hay `string`, nơi mọi thao tác "thay đổi" thực chất đều tạo ra một đối tượng mới.
    

## 2: Phân Loại Toàn Diện các Thao Tác với List: Phương Thức, Hàm và Toán Tử

Việc thao tác với `List` trong Python có thể được thực hiện thông qua các phương thức của đối tượng `List`, các hàm tích hợp của Python, và các toán tử. Một sự phân loại và phân tích rõ ràng các công cụ này là cần thiết để sử dụng chúng một cách chính xác và hiệu quả.

### 2.1. Truy Cập và Cắt Lát (Slicing)

Các thao tác truy cập và cắt lát là những cách cơ bản để đọc dữ liệu từ một `List` mà không làm thay đổi nó. Tài liệu đã trình bày chi tiết về các kỹ thuật này :

* **Lập chỉ mục xuôi (Forward Indexing):** Sử dụng các chỉ mục không âm, bắt đầu từ 0 cho phần tử đầu tiên. Ví dụ: `data` trả về phần tử đầu tiên.
    
* **Lập chỉ mục ngược (Backward Indexing):** Sử dụng các chỉ mục âm, bắt đầu từ -1 cho phần tử cuối cùng. Ví dụ: `data[-1]` trả về phần tử cuối cùng.
    
* **Cắt lát (Slicing):** Sử dụng cú pháp `list[start:end:step]` để trích xuất một đoạn của `List`. Các tham số `start`, `end`, và `step` là tùy chọn. Ví dụ: `data[:3]` trích xuất các phần tử từ đầu đến chỉ mục 2, và `data[::2]` trích xuất các phần tử ở chỉ mục chẵn.
    

Một điểm kỹ thuật quan trọng cần nhấn mạnh là thao tác cắt lát luôn tạo ra một **bản sao nông (shallow copy)** mới của các phần tử được chọn. Nó không tạo ra một "khung nhìn" (view) vào `List` gốc. Điều này có nghĩa là việc thay đổi `List` con được tạo ra từ slicing sẽ không ảnh hưởng đến `List` ban đầu. Độ phức tạp của việc truy cập theo chỉ mục là O(1), trong khi độ phức tạp của slicing là O(k), với k là kích thước của lát cắt.

### 2.2. Thao Tác Thay Đổi Tại Chỗ (In-Place) và Hàm Trả về Đối Tượng Mới

Một trong những điểm gây nhầm lẫn phổ biến nhất cho người mới học Python là sự khác biệt giữa các thao tác thay đổi `List` tại chỗ và các thao tác tạo ra một `List` mới.

Các phương thức như `.append()`, `.extend()`, `.sort()`, và `.reverse()` là các **thao tác thay đổi tại chỗ (mutators)**. Chúng sửa đổi trực tiếp đối tượng `List` mà chúng được gọi trên. Một quy ước thiết kế quan trọng trong Python là các phương thức này **trả về** `None`. Mục đích của việc này là để báo hiệu một cách rõ ràng rằng thao tác đã xảy ra trên đối tượng gốc và không có đối tượng mới nào được tạo ra. Một lỗi phổ biến là viết `my_list = my_list.sort()`, điều này sẽ khiến `my_list` bị gán giá trị `None`, làm mất đi `List` ban đầu.

Ngược lại, các hàm tích hợp như `sorted()` và `reversed()`, cũng như các toán tử như `+`, được thiết kế để hoạt động trên `List` gốc nhưng **trả về một đối tượng mới** (một `List` mới hoặc một iterator) mà không làm thay đổi `List` ban đầu.

Sự đối lập này được minh họa rõ nhất qua các cặp sau:

* `.sort()` vs. `sorted()`: `data.sort()` sắp xếp `data` tại chỗ và trả về `None`. `sorted_data = sorted(data)` tạo ra một `List` mới đã được sắp xếp và gán nó cho `sorted_data`, trong khi `data` vẫn không thay đổi.
    
* `.reverse()` vs. `reversed()`: `data.reverse()` đảo ngược `data` tại chỗ và trả về `None`. `reversed_iterator = reversed(data)` trả về một đối tượng iterator đảo ngược, không thay đổi `data` gốc.
    

Hiểu rõ sự phân biệt này là tối quan trọng để tránh các lỗi logic và quản lý trạng thái của dữ liệu một cách chính xác.

### 2.3. Phân Loại các Phương Thức List theo Chức Năng

Tài liệu tại trang 17 cung cấp một danh sách tổng quan về các phương thức của `List`, sau đó được chi tiết hóa ở các trang tiếp theo. Chúng có thể được phân loại theo mục đích sử dụng, cùng với các phân tích về hiệu năng và cách xử lý lỗi.

**Nhóm Thêm Phần Tử:**

* `.append(element)`: Thêm một phần tử vào cuối `List`. Hiệu năng cao (amortized O(1)).
    
* `.insert(index, element)`: Chèn một phần tử vào vị trí `index` cụ thể. Thao tác này tốn kém hơn (`O(n)`) do cần dịch chuyển các phần tử khác.
    
* `.extend(iterable)`: Nối tất cả các phần tử từ một đối tượng lặp được (iterable) vào cuối `List`. Hiệu năng tốt hơn việc lặp và `append` từng phần tử, với độ phức tạp O(k) với k là số phần tử trong iterable được thêm vào.
    

**Nhóm Xóa Phần Tử:**

* `.remove(value)`: Tìm và xóa lần xuất hiện đầu tiên của `value`. Thao tác này có độ phức tạp O(n) vì nó có thể phải duyệt qua toàn bộ `List` để tìm giá trị. Nó sẽ gây ra lỗi `ValueError` nếu `value` không tồn tại trong `List`.
    
* `.pop(index=-1)`: Xóa và trả về phần tử tại `index`. Nếu không có `index` được cung cấp, nó sẽ xóa và trả về phần tử cuối cùng (thao tác O(1)). Nếu `index` được chỉ định, nó có độ phức tạp O(n).
    
* `.clear()`: Xóa tất cả các phần tử khỏi `List`, làm cho nó trở thành một `List` rỗng. Đây là thao tác O(1).
    
* `del list[index]` hoặc `del list[slice]`: Từ khóa `del` là một câu lệnh Python tổng quát hơn, có thể xóa một phần tử hoặc một lát cắt khỏi `List` tại chỗ.
    

**Toán tử** `+` và `*`: Tài liệu tại trang 27 minh họa việc sử dụng các toán tử `+` để nối `List` và `*` để lặp lại `List`. Điều quan trọng cần lưu ý là cả hai toán tử này đều **tạo ra một** `List` mới. Ví dụ, `data = data1 + data2` tạo ra một `List` `data` hoàn toàn mới chứa các phần tử của `data1` và `data2`. Đối với các `List` lớn, việc này có thể kém hiệu quả về mặt bộ nhớ so với việc sử dụng phương thức tại chỗ như `.extend()`.

### 2.4. Khảo Sát các Hàm Tích Hợp (Built-in) Thiết Yếu

Python cung cấp nhiều hàm tích hợp có thể hoạt động trên `List` và các đối tượng lặp được khác. Các hàm này có thể được nhóm thành hai loại chính.

**Nhóm Hàm Tổng Hợp (Aggregate Functions):**

* `len(list)`: Trả về số lượng phần tử trong `List`.
    
* `min(list)`: Trả về phần tử có giá trị nhỏ nhất.
    
* `max(list)`: Trả về phần tử có giá trị lớn nhất.
    
* `sum(list, start=0)`: Trả về tổng của tất cả các phần tử (phải là số), có thể cộng thêm một giá trị `start` ban đầu.
    

**Nhóm Hàm Dựa trên Iterator (Iterator-based Functions):** Các hàm này hiệu quả về bộ nhớ vì chúng trả về các đối tượng iterator, vốn chỉ tạo ra các giá trị khi được yêu cầu (lazy evaluation), thay vì tạo ra một `List` đầy đủ trong bộ nhớ ngay lập tức.

* `sorted(iterable, reverse=False)`: Trả về một `List` mới được sắp xếp từ các phần tử của iterable.
    
* `reversed(sequence)`: Trả về một iterator đảo ngược các phần tử của sequence.
    
* `enumerate(iterable, start=0)`: Trả về một iterator tạo ra các cặp `(index, value)`.
    
* `zip(*iterables)`: Trả về một iterator tạo ra các tuple, trong đó tuple thứ `i` chứa phần tử thứ `i` từ mỗi iterable đầu vào.
    

Việc sử dụng các hàm dựa trên iterator đặc biệt quan trọng khi làm việc với các tập dữ liệu lớn, nơi việc tạo các `List` trung gian có thể tiêu tốn một lượng bộ nhớ đáng kể. Ví dụ, `for item in reversed(my_list):` sẽ tiết kiệm bộ nhớ hơn so với `for item in my_list[::-1]:` vì vế sau trước tiên phải tạo một bản sao đầy đủ của `my_list` đã được đảo ngược trong bộ nhớ.

### Bảng 1: Bảng Tra Cứu Toàn Diện về List trong Python

Bảng dưới đây tổng hợp các thao tác chính với `List`, làm rõ các thuộc tính quan trọng như việc thay đổi tại chỗ, giá trị trả về và độ phức tạp thời gian, nhằm cung cấp một tài liệu tham khảo nhanh và chính xác.

<table><tbody><tr><td colspan="1" rowspan="1"><p>Thao Tác</p></td><td colspan="1" rowspan="1"><p>Cú Pháp Ví Dụ</p></td><td colspan="1" rowspan="1"><p>Mô Tả</p></td><td colspan="1" rowspan="1"><p>Thay Đổi Tại Chỗ?</p></td><td colspan="1" rowspan="1"><p>Giá Trị Trả Về</p></td><td colspan="1" rowspan="1"><p>Độ Phức Tạp (Trung Bình)</p></td></tr><tr><td colspan="1" rowspan="1"><p><strong>Thêm Phần Tử</strong></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p>Append</p></td><td colspan="1" rowspan="1"><p><code>L.append(x)</code></p></td><td colspan="1" rowspan="1"><p>Thêm <code>x</code> vào cuối <code>L</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(1) (trừ dần)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Insert</p></td><td colspan="1" rowspan="1"><p><code>L.insert(i, x)</code></p></td><td colspan="1" rowspan="1"><p>Chèn <code>x</code> vào vị trí <code>i</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(n)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Extend</p></td><td colspan="1" rowspan="1"><p><code>L.extend(iter)</code></p></td><td colspan="1" rowspan="1"><p>Nối tất cả các phần tử từ <code>iter</code> vào <code>L</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(k)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Nối (Concatenate)</p></td><td colspan="1" rowspan="1"><p><code>L1 + L2</code></p></td><td colspan="1" rowspan="1"><p>Tạo một list mới từ <code>L1</code> và <code>L2</code>.</p></td><td colspan="1" rowspan="1"><p>Không</p></td><td colspan="1" rowspan="1"><p>List mới</p></td><td colspan="1" rowspan="1"><p>O(n+k)</p></td></tr><tr><td colspan="1" rowspan="1"><p><strong>Xóa Phần Tử</strong></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p>Pop (cuối)</p></td><td colspan="1" rowspan="1"><p><code>L.pop()</code></p></td><td colspan="1" rowspan="1"><p>Xóa và trả về phần tử cuối cùng.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p>Phần tử bị xóa</p></td><td colspan="1" rowspan="1"><p>O(1)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Pop (chỉ mục)</p></td><td colspan="1" rowspan="1"><p><code>L.pop(i)</code></p></td><td colspan="1" rowspan="1"><p>Xóa và trả về phần tử tại vị trí <code>i</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p>Phần tử bị xóa</p></td><td colspan="1" rowspan="1"><p>O(n)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Remove</p></td><td colspan="1" rowspan="1"><p><code>L.remove(x)</code></p></td><td colspan="1" rowspan="1"><p>Xóa lần xuất hiện đầu tiên của <code>x</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(n)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Clear</p></td><td colspan="1" rowspan="1"><p><code>L.clear()</code></p></td><td colspan="1" rowspan="1"><p>Xóa tất cả các phần tử khỏi <code>L</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(1)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Delete Slice</p></td><td colspan="1" rowspan="1"><p><code>del L[i:j]</code></p></td><td colspan="1" rowspan="1"><p>Xóa lát cắt từ <code>i</code> đến <code>j</code> khỏi <code>L</code>.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>N/A</code></p></td><td colspan="1" rowspan="1"><p>O(n)</p></td></tr><tr><td colspan="1" rowspan="1"><p><strong>Truy Vấn &amp; Sắp Xếp</strong></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td><td colspan="1" rowspan="1"><p></p></td></tr><tr><td colspan="1" rowspan="1"><p>Indexing</p></td><td colspan="1" rowspan="1"><p><code>L[i]</code></p></td><td colspan="1" rowspan="1"><p>Truy cập phần tử tại vị trí <code>i</code>.</p></td><td colspan="1" rowspan="1"><p>Không</p></td><td colspan="1" rowspan="1"><p>Phần tử tại <code>i</code></p></td><td colspan="1" rowspan="1"><p>O(1)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Slicing</p></td><td colspan="1" rowspan="1"><p><code>L[i:j]</code></p></td><td colspan="1" rowspan="1"><p>Lấy một lát cắt từ <code>i</code> đến <code>j</code>.</p></td><td colspan="1" rowspan="1"><p>Không</p></td><td colspan="1" rowspan="1"><p>List mới (bản sao nông)</p></td><td colspan="1" rowspan="1"><p>O(k)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Sort Method</p></td><td colspan="1" rowspan="1"><p><code>L.sort()</code></p></td><td colspan="1" rowspan="1"><p>Sắp xếp <code>L</code> tại chỗ.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(nlogn)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Sorted Function</p></td><td colspan="1" rowspan="1"><p><code>sorted(L)</code></p></td><td colspan="1" rowspan="1"><p>Trả về một list mới đã được sắp xếp từ <code>L</code>.</p></td><td colspan="1" rowspan="1"><p>Không</p></td><td colspan="1" rowspan="1"><p>List mới đã sắp xếp</p></td><td colspan="1" rowspan="1"><p>O(nlogn)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Reverse Method</p></td><td colspan="1" rowspan="1"><p><code>L.reverse()</code></p></td><td colspan="1" rowspan="1"><p>Đảo ngược <code>L</code> tại chỗ.</p></td><td colspan="1" rowspan="1"><p>Có</p></td><td colspan="1" rowspan="1"><p><code>None</code></p></td><td colspan="1" rowspan="1"><p>O(n)</p></td></tr><tr><td colspan="1" rowspan="1"><p>Copy Method</p></td><td colspan="1" rowspan="1"><p><code>L.copy()</code></p></td><td colspan="1" rowspan="1"><p>Tạo một bản sao nông của <code>L</code>.</p></td><td colspan="1" rowspan="1"><p>Không</p></td><td colspan="1" rowspan="1"><p>List mới (bản sao nông)</p></td><td colspan="1" rowspan="1"><p>O(n)</p></td></tr></tbody></table>

*Lưu ý: n là số phần tử trong* `List` L, k là số phần tử trong iterable được thêm vào.

## Phần 3: Tư Duy Thuật Toán với List: Phân Tích các Bài Toán Thực Hành

Việc nắm vững cú pháp chỉ là bước đầu tiên. Giá trị thực sự của một cấu trúc dữ liệu nằm ở việc áp dụng nó để giải quyết các vấn đề. Các bài toán thực hành trong tài liệu cung cấp cơ hội để chuyển từ việc "biết" cú pháp sang "hiểu" cách áp dụng và phân tích thuật toán.

### 3.1. Nghiên Cứu Tình Huống 1: "Tổng các số chẵn" (Sum of Even Numbers)

Bài toán này yêu cầu tính tổng các số chẵn trong một `List` cho trước. Tài liệu trình bày hai giải pháp: một sử dụng vòng lặp `for` và một sử dụng vòng lặp `while`.

* **Giải pháp 1 (vòng lặp** `for`): `for value in data:`
    
* **Giải pháp 2 (vòng lặp** `while`): `while index < len(data):`
    

Về mặt thuật toán, cả hai giải pháp này đều giống hệt nhau. Chúng đều duyệt qua từng phần tử của `List` một lần, kiểm tra xem phần tử đó có phải là số chẵn hay không, và cộng vào một biến tổng. Do đó, cả hai đều có độ phức tạp thời gian là O(n), với n là số phần tử trong `List`.

Tuy nhiên, sự khác biệt giữa chúng lại là một bài học quan trọng về phong cách lập trình và tính dễ đọc của mã (code readability). Vòng lặp `for value in data:` được coi là "Pythonic" hơn trong trường hợp này. Nó trừu tượng hóa việc quản lý chỉ mục, cho phép lập trình viên tập trung trực tiếp vào logic xử lý trên từng "giá trị" (value). Mã nguồn trở nên ngắn gọn và thể hiện rõ ý định hơn.

Ngược lại, vòng lặp `while` yêu cầu quản lý chỉ mục (`index`) một cách thủ công: khởi tạo `index = 0`, kiểm tra điều kiện `index < len(data)`, và tăng `index = index + 1` sau mỗi lần lặp. Cách tiếp cận này dài dòng hơn và dễ gây ra lỗi, chẳng hạn như lỗi lặp vô hạn nếu quên tăng chỉ mục. Mặc dù nó cung cấp sự kiểm soát chi tiết hơn đối với quá trình lặp (hữu ích trong một số trường hợp phức tạp hơn), nhưng đối với việc duyệt qua một `List` đơn giản, vòng lặp `for` là lựa chọn ưu việt hơn về mặt phong cách và sự an toàn.

### 3.2. Nghiên Cứu Tình Huống 2: "Two Sum"

Đây là một bài toán kinh điển trong khoa học máy tính và là một ví dụ tuyệt vời để minh họa các khái niệm nâng cao hơn. Bài toán yêu cầu tìm các cặp chỉ mục của hai số trong một `List` có tổng bằng một giá trị `target` cho trước. Tài liệu đã trình bày hai cách tiếp cận khác nhau.

**Cách tiếp cận 1: Brute-Force (Vét cạn)** Giải pháp đầu tiên sử dụng hai vòng lặp lồng nhau để kiểm tra mọi cặp phần tử có thể có trong `List`.

```python
# Tóm tắt logic từ slide
for i in range(n):
    for j in range(i + 1, n):
        if nums[i] + nums[j] == target:
            # tìm thấy một cặp
```

Giải pháp này dễ hiểu, nhưng không hiệu quả. Vòng lặp ngoài chạy n lần, và với mỗi lần lặp của vòng lặp ngoài, vòng lặp trong chạy trung bình n/2 lần. Điều này dẫn đến độ phức tạp thời gian là O(n2). Đối với các `List` có kích thước lớn, thời gian thực thi sẽ tăng lên theo hàm bậc hai, trở nên rất chậm. Về mặt không gian, giải pháp này rất hiệu quả, chỉ sử dụng một lượng bộ nhớ không đổi, hay O(1).

**Cách tiếp cận 2: Tối ưu hóa bằng Bảng băm (Dictionary/Hash Map)** Giải pháp thứ hai, được trình bày từ trang 48, sử dụng một cấu trúc dữ liệu phụ là `dictionary` (hoạt động như một bảng băm) để tối ưu hóa đáng kể thời gian chạy.

```python
# Tóm tắt logic từ slide
num_indices = {}
for i, num in enumerate(data):
    complement = target - num
    if complement in num_indices:
        # tìm thấy một cặp
    num_indices[num] = i
```

Trong giải pháp này, chúng ta chỉ duyệt qua `List` một lần duy nhất. Tại mỗi phần tử `num`, chúng ta tính toán "phần bù" (`complement`) cần thiết để đạt được `target`. Sau đó, chúng ta kiểm tra xem `complement` đã có trong `dictionary` `num_indices` hay chưa. `dictionary` lưu trữ các số đã gặp và chỉ mục của chúng. Thao tác kiểm tra sự tồn tại của một khóa (`in`) và truy cập giá trị trong `dictionary` có độ phức tạp trung bình là O(1). Nếu `complement` được tìm thấy, chúng ta đã có một cặp hợp lệ. Sau đó, chúng ta thêm `num` và chỉ mục `i` của nó vào `dictionary` để sử dụng cho các lần lặp sau.

Vì chúng ta chỉ duyệt qua `List` một lần, độ phức tạp thời gian của giải pháp này là O(n), một sự cải thiện vượt bậc so với O(n2). Tuy nhiên, sự cải thiện này phải trả giá. Chúng ta cần thêm một `dictionary` để lưu trữ thông tin, và trong trường hợp xấu nhất, `dictionary` này sẽ chứa tất cả n phần tử của `List`. Do đó, độ phức tạp không gian của giải pháp này là O(n).

Sự so sánh giữa hai giải pháp này minh họa một trong những nguyên lý đánh đổi (trade-off) cơ bản nhất trong khoa học máy tính: **đánh đổi giữa không gian và thời gian (space-time tradeoff)**. Giải pháp thứ hai "hy sinh" bộ nhớ (không gian) để đổi lấy tốc độ (thời gian). Đây là một bài học sâu sắc vượt ra ngoài cú pháp của `List`, giới thiệu cho người học về tư duy thiết kế và phân tích thuật toán.

# **M01W02 - Delving into List**

## **I. Giới thiệu về Data Structure và List**

### **Khái niệm Cấu trúc Dữ liệu**

Cấu trúc dữ liệu là phương thức tổ chức và lưu trữ dữ liệu trong máy tính để có thể truy cập và sử dụng một cách hiệu quả. Trong Python, cấu trúc dữ liệu được chia thành hai loại chính: Built-in Data Structures (List, Dictionary, Tuple, Set) và User-Defined Data Structures (Stack, Queue, Tree, Linked List, Graph).

### **Đặc điểm của List trong Python**

List là một cấu trúc dữ liệu **mutable (có thể thay đổi)**, **ordered (có thứ tự)** và **cho phép chứa các phần tử trùng lặp**. Các đặc điểm quan trọng của List bao gồm:

* **Ordered**: Các phần tử có thứ tự xác định và thứ tự này không thay đổi trừ khi có can thiệp.
    
* **Changeable**: Có thể thay đổi, thêm, xóa phần tử sau khi tạo.
    
* **Allow Duplicates**: Cho phép các phần tử có giá trị giống nhau.
    
* **Dynamic Size**: Kích thước có thể thay đổi trong quá trình thực thi
    

## **II. 1D List - Mảng Một Chiều**

### **Tạo và Khởi tạo List**

List được tạo bằng cách sử dụng dấu ngoặc vuông `[]` và các phần tử được phân cách bởi dấu phẩy:

```python
# Tạo list rỗng
empty_list = []

# List số tự nhiên
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# List hỗn hợp nhiều kiểu dữ liệu
mixed_list = [True, 5, 'some string', 123.45]

# List lồng nhau
nested_list = ["Happy", [2, 0, 1, 5]]

# List thực tế
shopping_list = ['táo', 'chuối', 'cherries', 'dâu', 'mận']
```

### **Indexing và Slicing**

List trong Python hỗ trợ cả forward indexing (bắt đầu từ 0) và backward indexing (bắt đầu từ -1)

```python
data = [4, 5, 6, 7, 8, 9]

# Forward indexing
print(data[0])    # Output: 4
print(data[3])    # Output: 7

# Backward indexing  
print(data[-1])   # Output: 9
print(data[-3])   # Output: 7

# Slicing: list[start:end:step]
print(data[2:4])  # Output: [6, 7]
print(data[3:])   # Output: [7, 8, 9]
print(data[:3])   # Output: [4, 5, 6]
```

### **Các Phép toán Cơ bản**

List hỗ trợ các phép toán **nối (+)** và **nhân (\*)** để tạo list mới:

```python
data1 = [6, 5, 7]
data2 = [1, 9, 2]

# Nối hai list
combined = data1 + data2  # [6, 5, 7, 1, 9, 2]

# Nhân list với số nguyên
repeated = data1 * 3      # [6, 5, 6, 5, 6, 5]
```

### **Phương thức Built-in**

List cung cấp nhiều phương thức hữu ích để **thao tác dữ liệu**:

```python
data = [6, 5, 7, 1, 9, 2]

# Thêm phần tử
data.append(4)           # Thêm vào cuối
data.insert(0, 4)        # Thêm vào vị trí chỉ định
data.extend([9, 2])      # Thêm nhiều phần tử

# Cập nhật phần tử
data[1] = 4              # Thay đổi giá trị tại index 1

# Xóa phần tử
data.pop(2)              # Xóa theo index
data.remove(5)           # Xóa theo giá trị
del data[1:3]            # Xóa nhiều phần tử
data.clear()             # Xóa tất cả

# Sắp xếp và đảo ngược
data.sort()              # Sắp xếp tăng dần
data.sort(reverse=True)  # Sắp xếp giảm dần
data.reverse()           # Đảo ngược thứ tự
```

### **Built-in Functions cho List**

Python cung cấp **nhiều hàm built-in** để xử lý List:

```python
data = [6, 5, 7, 1, 9, 2]

length = len(data)        # Độ dài: 6
minimum = min(data)       # Giá trị nhỏ nhất: 1
maximum = max(data)       # Giá trị lớn nhất: 9
total = sum(data)         # Tổng: 30

# Sắp xếp không thay đổi list gốc
sorted_data = sorted(data)           # Tăng dần
sorted_desc = sorted(data, reverse=True)  # Giảm dần
```

### **List Comprehension**

**List comprehension** cho phép tạo list mới một cách ngắn gọn và hiệu quả:

```python
# Cú pháp cơ bản: [expression for item in iterable if condition]

# Bình phương các số
squares = [x**2 for x in range(1, 11)]  # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# Với điều kiện
even_squares = [x**2 for x in range(1, 11) if x % 2 == 0]  # [4, 16, 36, 64, 100]

# Với mệnh đề if-else
data = [1, 5, -4, 3, -2]
relu_values = [x if x > 0 else 0 for x in data]  # [1, 5, 0, 3, 0]
```

## **III. 2D List - Mảng Hai Chiều**

### **Khái niệm và Ứng dụng**

**2D List** là cấu trúc dữ liệu **hai chiều** được sử dụng để **biểu diễn dữ liệu dạng bảng, ma trận hoặc lưới**. Trong thực tế, **2D List** được ứng dụng rộng rãi trong:

* **Ma trận toán học**: Tính toán đại số tuyến tính.
    
* **Digital Images**: Biểu diễn pixel và xử lý ảnh.
    
* **Game Development**: Bàn cờ, lưới game.
    
* **Data Analysis**: Bảng dữ liệu và spreadsheet.
    

### **Tạo và Truy cập 2D List**

```python
# Tạo 2D List
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Truy cập phần tử: matrix[row][column]
print(matrix[0][0])  # Output: 1
print(matrix[1][1])  # Output: 5
print(matrix[2][2])  # Output: 9

# Kích thước ma trận
num_rows = len(matrix)      # 3 hàng
num_cols = len(matrix[0])   # 3 cột
```

### **Duyệt qua 2D List**

Có hai cách chính để duyệt qua 2D List:

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Phương pháp 1: Sử dụng for-in
for row in matrix:
    for element in row:
        print(element, end=' ')
    print()

# Phương pháp 2: Sử dụng index
num_rows = len(matrix)
num_cols = len(matrix[0])
for r in range(num_rows):
    for c in range(num_cols):
        print(matrix[r][c], end=' ')
    print()
```

### **Cập nhật và Thao tác 2D List**

```python
# Cập nhật phần tử
matrix[1][1] = 0  # Thay đổi giá trị tại hàng 1, cột 1

# Tạo 2D List với kích thước xác định
rows, cols = 3, 3
matrix = [[0 for j in range(cols)] for i in range(rows)]
```

### **Hadamard Product (Phép nhân Element-wise)**

**Hadamard Product** là phép **nhân từng phần tử** tương ứng của hai ma trận:

```python
# Hadamard Product
G = [[3, 5, 7], [4, 9, 8]]
H = [[1, 6, 3], [0, 2, 9]]

num_rows = len(G)
num_cols = len(G[0])
result = [[0]*num_cols for _ in range(num_rows)]

for r in range(num_rows):
    for c in range(num_cols):
        result[r][c] = G[r][c] * H[r][c]

# Result: [[3, 30, 21], [0, 18, 72]]
```

## **IV. Algorithms trên List**

### **Linear Search Algorithm**

**Linear Search** là thuật toán tìm kiếm cơ bản nhất, kiểm tra từng phần tử một cách tuần tự từ đầu đến cuối list.

![Minh họa thuật toán Linear Search](https://pplx-res.cloudinary.com/image/upload/v1749913546/pplx_code_interpreter/dbda88c4_yxr7fd.jpg align="left")

**Cài đặt Linear Search:**

```python
def linear_search(data, target):
    """
    Thuật toán tìm kiếm tuyến tính
    Độ phức tạp: O(n)
    """
    for i in range(len(data)):
        if data[i] == target:
            return i  # Trả về index của phần tử tìm thấy
    return -1  # Không tìm thấy

data = [6, 5, 7, 1, 9, 2]
print(linear_search(data, 9))  # Output: 4
print(linear_search(data, 8))  # Output: -1
```

**Đặc điểm Linear Search:**

* **Độ phức tạp thời gian**: O(n) trong trường hợp xấu nhất.
    
* **Độ phức tạp không gian**: O(1).
    
* **Ưu điểm**: Đơn giản, hoạt động với mọi loại dữ liệu.
    
* **Nhược điểm**: Chậm với dữ liệu lớn.
    

### **Sorting Algorithms**

**Simple Sorting sử dụng min(), remove(), append()**

```python
def simple_sort(data):
    """
    Thuật toán sắp xếp đơn giản
    Độ phức tạp: O(n²)
    """
    data_copy = data.copy()
    result = []
    
    while data_copy:
        min_value = min(data_copy)
        result.append(min_value)
        data_copy.remove(min_value)
    
    return result
```

### **So sánh độ phức tạp các Thuật toán Sắp xếp (Sorting algorithm)**

**Độ phức tạp Thuật toán**

Độ phức tạp thuật toán là thước đo hiệu suất của thuật toán theo kích thước đầu vào:

![Biểu đồ so sánh độ phức tạp các thuật toán](https://pplx-res.cloudinary.com/image/upload/v1749913372/pplx_code_interpreter/3b91d8a1_vgkimc.jpg align="left")

**Các loại độ phức tạp phổ biến:**

* **O(1)**: Constant time - Thời gian hằng số.
    
* **O(log n)**: Logarithmic time - Tìm kiếm nhị phân.
    
* **O(n)**: Linear time - Linear search.
    
* **O(n log n)**: Linearithmic time - Merge sort, Quick sort.
    
* **O(n²)**: Quadratic time - Bubble sort, Insertion sort.
    
* **O(2^n)**: Exponential time - Brute force algorithms.
    

## **V. Kiến thức Mở rộng**

### **Activation Functions trong Neural Networks**

**Hàm Sigmoid**

**Hàm Sigmoid** là một trong những hàm kích hoạt quan trọng nhất trong neural networks:

**Công thức toán học: σ(x)=1/e^(-x)**

**Đặc điểm:**

* **Domain**: (-∞, +∞)
    
* **Range**: (0, 1)
    
* **Tính chất**: Monotonic, continuous, differentiable
    
* **Đạo hàm**: σ'(x) = σ(x)(1 - σ(x))
    

```python
import math

def sigmoid(x): #Hàm Sigmoid
    return 1 / (1 + math.exp(-x))

def sigmoid_for_list(data): #Áp dụng sigmoid cho list
    return [sigmoid(x) for x in data]

data = [1, 5, -4, 3, -2]
result = sigmoid_for_list(data)
# Output: [0.731, 0.993, 0.018, 0.953, 0.119]
```

### **Hàm ReLU**

ReLU (Rectified Linear Unit) là hàm kích hoạt phổ biến nhất trong deep learning hiện đại:

**Công thức toán học:**  
ReLU(x) = max⁡(0,x) = {

```python
def relu(x): #Hàm ReLU
    return max(0, x)

def relu_for_list(data): #Áp dụng ReLU cho list
    return [relu(x) for x in data]

def relu_list_comprehension(data): # Sử dụng List Comprehension
    return [x if x > 0 else 0 for x in data]

data = [1, 5, -4, 3, -2]
result = relu_list_comprehension(data)
# Output: [1, 5, 0, 3, 0]
```

![Biểu đồ minh họa hàm Sigmoid và ReLU](https://pplx-res.cloudinary.com/image/upload/v1749913469/pplx_code_interpreter/a553ade9_qhskd2.jpg align="left")

Biểu đồ minh họa hàm Sigmoid và ReLU

**Ưu điểm của ReLU:**

* Giải quyết vấn đề vanishing gradient
    
* Tính toán nhanh và đơn giản
    
* Thúc đẩy sparsity trong neural networks
    

### **Prefix Sum Array Technique**

**Prefix Sum Array** (hay Integral Array) là kỹ thuật **tối ưu hóa** quan trọng cho việc tính tổng trong đoạn:

![Minh họa Prefix Sum Array (mảng tổng tiền tố)](https://pplx-res.cloudinary.com/image/upload/v1749913629/pplx_code_interpreter/7ba0d467_lycigg.jpg align="left")

**Khái niệm:**  
**Prefix Sum Array** là mảng mà **mỗi phần tử tại vị trí i** chứa **tổng** của **tất cả phần tử từ đầu mảng đến vị trí i.**

**Công thức:**  
F\[x\] = f\[x\] + F\[x − 1\]  
Sum\[a : b\] = F\[b\] − F\[a − 1\]

```python
def build_prefix_sum(data):
    """Xây dựng mảng tổng tiền tố"""
    prefix_sum = [0] * len(data)
    prefix_sum[0] = data[0]
    
    for i in range(1, len(data)):
        prefix_sum[i] = data[i] + prefix_sum[i-1]
    
    return prefix_sum

def range_sum(prefix_sum, left, right):
    """Tính tổng trong đoạn [left, right] với O(1)"""
    if left == 0:
        return prefix_sum[right]
    return prefix_sum[right] - prefix_sum[left-1]


original_data = [1, 8, 5, 7, 3, 5, 8, 3]
prefix_array = build_prefix_sum(original_data)
# prefix_array = [1, 9, 14, 21, 24, 29, 37, 40]

# Tính tổng từ index 3 đến 6: O(1)
result = range_sum(prefix_array, 3, 6)  # Output: 23
```

**Ứng dụng thực tế:**

* **Computer Vision**: Integral Image trong object detection
    
* **Competitive Programming**: Giải quyết range sum queries
    
* **Database Optimization**: Tối ưu hóa aggregate queries
    
* **Signal Processing**: Tính convolution và filtering
    

### **Mutable vs Immutable Operations**

```python
# Immutable - Tạo list mới
def square_immutable(data):
    result = []
    for value in data:
        result.append(value * value)
    return result

# Mutable - Thay đổi list gốc
def square_mutable(data):
    for i in range(len(data)):
        data[i] = data[i] * data[i]

data = [6, 5, 7, 1, 9, 2]
new_data = square_immutable(data)  # data không đổi
square_mutable(data)               # data bị thay đổi
```

## **VI. Kết luận và Hướng phát triển**

### **Tóm tắt Kiến thức**

List là cấu trúc dữ liệu fundamental trong Python với nhiều tính năng mạnh [m](https://www.w3schools.com/python/python_lists.asp)[ẽ](https://www.digitalocean.com/community/tutorials/understanding-lists-in-python-3). Từ những thao tác cơ bản như [i](https://www.digitalocean.com/community/tutorials/understanding-lists-in-python-3)ndexing và slicin[g](https://www.w3schools.com/python/python_lists.asp) đến các thuật toán phức tạp như sorting và searching, List đóng vai trò then chốt trong hầu hết các ứng dụng Pyth[o](https://www.topcoder.com/thrive/articles/python-data-structures-list-and-tuples)n. Hiểu rõ về độ phức tạp thuật [t](https://www.topcoder.com/thrive/articles/python-data-structures-list-and-tuples)oán giúp chúng ta [l](https://www.topcoder.com/thrive/articles/python-data-structures-list-and-tuples)ựa chọn phương pháp tối ưu cho từng bài toán cụ thể.

### **Hướng Phát triển**

Để nâng cao kỹ năng làm việc với List, chúng ta nên:

1. **Thực hành thuật toán**: Implement các sorting algorithms khác nhau
    
2. **Tối ưu hóa hiệu suất**: Sử dụng NumPy cho các phép toán ma trận phức tạp
    
3. **Ứng dụng thực tế**: Áp dụng vào computer vision và data science
    
4. **Học advanced techniques**: Dynamic programming với prefix sum
    

**Nguồn tham khảo (tài liệu gốc):** [**Data Structure Delving into List**](https://aivnlearning.edu.vn/api/files/68317562519c0e157fb51480/Documents%2F2025-5%2FM01W02%20-%20Delving%20into%20List%2FM01W02_DataStructure_List_v4.pdf)

# **M01W02 - Database - SQL (2)**

## **1\. Giới thiệu về ERD (Entity Relationship Diagram)**

**Khái niệm**

ERD là sơ đồ trực quan hóa các thực thể (entity) trong hệ thống và mối quan hệ giữa chúng. Đây là công cụ nền tảng để thiết kế, mô hình hóa cơ sở dữ liệu quan hệ, giúp bạn hình dung cấu trúc logic trước khi xây dựng thực tế.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749985522315/0911b190-d0d4-4789-afd9-1a2d812407c5.png align="center")

## **2\. Các ký hiệu và thành phần cơ bản trong ERD**

**Nội dung:**

* **Thực thể (Entity):** Hình chữ nhật, đặt tên danh từ số ít.
    
* **Thuộc tính (Attribute):** Hình oval, nối với thực thể.
    
* **Khóa chính (Key Attribute):** Gạch chân tên thuộc tính.
    
* **Thuộc tính đa trị, tổng hợp, dẫn xuất:** Có ký hiệu riêng biệt.
    
* **Quan hệ (Relationship):** Hình thoi nối giữa các thực thể.
    
* **Bội số (Cardinality):** Chân quạ hoặc số (1, N, M).
    

## **Thực thể yếu(Weak Entity)**

Thực thể yếu là thực thể không thể xác định duy nhất chỉ bằng các thuộc tính của nó, mà phải kết hợp với khóa chính từ một thực thể khác (thực thể mạnh). Ví dụ điển hình là **Order Item** trong hệ thống bán hàng: một Order Item chỉ có ý nghĩa khi gắn với một Order cụ thể – nó phụ thuộc vào Order để tồn tại. Trong ERD, thực thể yếu thường được vẽ bằng hình chữ nhật viền đôi, và mối quan hệ xác định với thực thể mạnh cũng dùng đường viền đôi.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749986137542/51fb7852-5ff6-492c-8370-b893c71ed30b.png align="center")

## Thực thể liên kết (Associative Entity)

Thực thể liên kết dùng để biểu diễn mối quan hệ nhiều-nhiều giữa hai thực thể khác. Nó thường là bảng trung gian chứa khóa ngoại của hai thực thể liên quan, đồng thời có thể có thêm các thuộc tính riêng (ví dụ: số lượng, đơn giá trong Order Item). Trong ERD, thực thể liên kết cũng được vẽ như một thực thể bình thường.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749986177315/42e64fc3-db91-4789-8b54-b78d3e2a403d.png align="center")

## **Thuộc tính (Attribute) trong ERD**

Thuộc tính là đặc điểm mô tả cho thực thể, giúp nhận diện hoặc bổ sung thông tin cho từng thực thể. Trong ERD, thuộc tính được vẽ bằng hình oval nối với thực thể.  
Có nhiều loại thuộc tính, gồm:

* **Thuộc tính đơn (simple/single-valued):** Không chia nhỏ được, ví dụ: Age, Gender.
    
* **Thuộc tính tổng hợp (composite):** Có thể chia thành các thành phần nhỏ hơn, ví dụ: Address gồm street, city, zip.
    
* **Thuộc tính đa trị (multivalued):** Có thể có nhiều giá trị cho một thực thể, ví dụ: một nhân viên có nhiều số điện thoại.
    
* **Thuộc tính dẫn xuất (derived):** Được tính từ thuộc tính khác, ví dụ: Age tính từ Birthdate.
    

## **4\. Các kiểu quan hệ và ràng buộc tham gia**

## **Các kiểu quan hệ trong ERD**

* **Quan hệ 1-1 (One-to-One, 1:1):** Một thực thể ở bảng A chỉ liên kết với tối đa một thực thể ở bảng B và ngược lại. Ví dụ: mỗi người chỉ có một hộ chiếu, mỗi hộ chiếu chỉ cấp cho một người.
    
* **Quan hệ 1-N (One-to-Many, 1:N):** Một thực thể ở bảng A có thể liên kết với nhiều thực thể ở bảng B, nhưng mỗi thực thể ở bảng B chỉ thuộc về một thực thể ở bảng A. Ví dụ: một khách hàng có nhiều đơn hàng, nhưng mỗi đơn hàng chỉ thuộc về một khách hàng.
    
* **Quan hệ N-M (Many-to-Many, M:N):** Một thực thể ở bảng A có thể liên kết với nhiều thực thể ở bảng B và ngược lại. Ví dụ: một sinh viên học nhiều môn, một môn có nhiều sinh viên đăng ký. Quan hệ này thường được chuyển thành hai quan hệ 1-N thông qua bảng liên kết.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749986561679/0d9664a6-fb20-436b-bea7-b3b02f12ef24.png align="center")

## **Ràng buộc tham gia (Participation Constraints)**

* **Tham gia toàn phần (Total Participation):** Mọi thực thể trong một tập thực thể bắt buộc phải tham gia vào quan hệ. Trong ERD, thường ký hiệu bằng đường đôi nối giữa thực thể và quan hệ. Ví dụ: mỗi chương phải thuộc về một cuốn sách.
    
* **Tham gia một phần (Partial Participation**[**)**](https://www.exploredatabase.com/2018/04/define-partial-participation-in-er-diagram-model.html)[**:**](https://www.cse.cuhk.edu.hk/~taoyf/course/bmeg3120/notes/er.pdf) Chỉ một số thực thể trong tập thực thể tham gia vào quan hệ, không bắt buộc tất cả. Ký hiệu bằng một đường đơn nối giữa thực thể và quan hệ. Ví dụ: không phải khách hàng nào cũng có đơn hàng, nên khách hàng tham gia một phần vào quan hệ với đơn hàng.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749986854078/a0aac91c-5132-4475-b0bd-cc916301661c.png align="center")

## Crow’s Foot Notation

**Định nghĩa**

**Crow’s Foot Notation** là một phương pháp ký hiệu trực quan, phổ biến nhất dùng để mô hình hóa các mối quan hệ giữa các thực thể trong ERD. Ký hiệu này sử dụng các hình dạng đặc trưng như “chân quạ” (ba nhánh), vạch dọc và vòng tròn để thể hiện số lượng (cardinality) và tính bắt buộc (modality) của mối quan hệ.

* **Vạch dọc (|):** Thể hiện “một” (one).
    
* **Chân quạ (crow’s foot):** Thể hiện “nhiều” (many).
    
* **Vòng tròn (o):** Thể hiện “không” (zero, tùy chọn).
    

Kết hợp các ký hiệu này, bạn có thể đọc được quan hệ 1-1, 1-nhiều, nhiều-nhiều, bắt buộc hoặc tùy chọn giữa các thực thể. Ví dụ: Một khách hàng có thể có nhiều đơn hàng (1:N), nhưng mỗi đơn hàng chỉ thuộc về một khách hàng (N:1)

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749987102373/83a1edcc-6d0e-466d-8f91-f92b02425390.png align="center")

## **Làm sao để vẽ ER Diagram**

1. **Xác định các thực thể (entities)**  
    Liệt kê tất cả các thực thể sẽ quản lý trong hệ thống (ví dụ: Customer, Product, Order). Vẽ mỗi thực thể bằng một hình chữ nhật và đặt tên rõ ràng.
    
2. **Xác định các mối quan hệ (relationships)**  
    Vẽ các đường nối giữa các thực thể để thể hiện quan hệ, có thể thêm hình thoi ở giữa để ghi chú tên quan hệ (theo Chen notation). Xác định kiểu quan hệ (1-1, 1-N, N-M) và ràng buộc tham gia.
    
3. **Thêm các thuộc tính (attributes)**  
    Vẽ các thuộc tính dưới dạng hình oval, nối với thực thể tương ứng. Đánh dấu thuộc tính khóa chính bằng gạch chân.
    
4. **Rà soát, sắp xếp lại sơ đồ**  
    Kiểm tra lại các thực thể, quan hệ, thuộc tính đã đầy đủ và hợp lý chưa. Sắp xếp sơ đồ cho dễ nhìn, logic.
    

## Một số công cụ vẽ ERD phổ biến

* **Lucidchart**  
    Công cụ online mạnh mẽ, hỗ trợ kéo thả, nhiều mẫu ERD, dễ cộng tác nhóm. Có bản miễn phí cho cá nhân và trả phí cho doanh nghiệp.
    
* **Draw.io (diagrams.net)**  
    Miễn phí hoàn toàn, chạy trên web hoặc cài offline, giao diện trực quan, tích hợp với Google Drive/OneDrive, phù hợp cho cả cá nhân lẫn nhóm.
    
* **dbdiagram.io**  
    Tạo ERD nhanh bằng cách nhập code, phù hợp cho developer, xuất file ảnh hoặc SQL, miễn phí bản cơ bản.
    
* **ERDPlus**  
    Web app đơn giản, miễn phí, hỗ trợ vẽ ERD, relational schema, star schema và xuất file PNG hoặc SQL.
    
* **QuickDBD**  
    Vẽ sơ đồ bằng cách nhập text, thao tác cực nhanh, miễn phí cho 1 diagram nhỏ, có bản trả phí mở rộng.
    
* **Visual Paradigm**  
    Công cụ chuyên nghiệp, nhiều template, hỗ trợ xuất ảnh không watermark, phù hợp cả cá nhân và doanh nghiệp.
    
* **Creately, Cacoo, Gliffy, SmartDraw, Canva, GitMind**  
    Các lựa chọn khác với giao diện kéo thả, nhiều mẫu đẹp, hỗ trợ làm việc nhóm và xuất file ở nhiều định dạng.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750000238348/1a1bd07d-1274-4834-ab29-209aeaa7b153.png align="center")

## Case Study: Thiết Kế ERD Cho Hệ Thống Bán Hàng

**1\. Xác định yêu cầu lưu trữ**  
Công ty muốn quản lý thông tin sản phẩm (tên, số lượng, giá), khách hàng (tên, ngày sinh, liên hệ, địa chỉ, điểm thưởng), đơn hàng (ngày đặt, trạng thái, ghi chú, ngày giao, shipper), và chi tiết từng sản phẩm trong mỗi đơn hàng.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750004860462/fa74f207-9cfb-43ca-b478-3a5856a6053e.png align="center")

**2\. Phát hiện vấn đề quan hệ nhiều-nhiều**  
Nếu chỉ liên kết trực tiếp khách hàng với sản phẩm, sẽ phát sinh lặp dữ liệu và khó quản lý: một khách hàng có thể mua nhiều sản phẩm, một sản phẩm bán cho nhiều khách hàng. Cách này dẫn tới dữ liệu bị dư thừa và khó kiểm soát khóa chính/phụ.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750005014388/abc37c86-7c89-4f9e-8094-497293685aca.png align="center")

**3\. Phân tích và giải quyết bằng bảng trung gian**  
Nhận ra cần thêm thực thể “Order” (Đơn hàng) và “Order Detail” (Chi tiết đơn hàng) để tách biệt quan hệ nhiều-nhiều giữa khách hàng và sản phẩm.

* Order lưu thông tin đơn hàng, liên kết với khách hàng.
    
* Order Detail lưu từng sản phẩm trong đơn hàng, số lượng, đơn giá, liên kết với Order và Product bằng khóa ngoại.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750005038959/08b718d3-cde9-4858-a57e-be7f26c8e875.png align="center")

**4\. Xây dựng sơ đồ ERD hoàn chỉnh**  
Sau khi thêm Order và Order Detail, sơ đồ ERD trở nên rõ ràng, dễ mở rộng:

* Customer (Khách hàng) –&lt; Order (Đơn hàng) –&lt; Order Detail (Chi tiết đơn hàng) &gt;– Product (Sản phẩm).
    
* Bổ sung các thực thể phụ như Shipper, Order Status nếu cần
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750005074105/acdbf35d-d02e-4824-9c86-4944975eb081.png align="center")

**5\. Minh họa bằng ví dụ dữ liệu**  
Đưa ra bảng mẫu cho từng thực thể: khách hàng, sản phẩm, đơn hàng, chi tiết đơn hàng… để người đọc hình dung dữ liệu thực tế sẽ được lưu thế nào và các khóa chính/ngoại liên kết ra sao

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750005090916/f53911b5-2b10-4c5e-a612-ae666429e228.png align="center")

## Triển khai sơ đồ ER

1\. Tổng quan chuyển ERD sang bảng dữ liệu

* **Nội dung:** Giới thiệu ý nghĩa của việc chuyển từ ERD sang các bảng thực tế trong DBMS, các nguyên tắc chung (mỗi thực thể thành một bảng, xác định khóa chính, khóa ngoại…).
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750036208195/e111e337-4d55-4bcc-9f30-961a17906316.png align="center")

2. **Xác định khóa chính, khóa ngoại**:  
    Đặt khóa chính (primary key) cho từng bảng, xác định các khóa ngoại (foreign key) để liên kết các bảng với nhau, đảm bảo ràng buộc toàn vẹn dữ liệu
    
3. **Cài đặt quan hệ một-nhiều, nhiều-nhiều**:
    
    * Với quan hệ 1-N: khóa ngoại nằm ở bảng “nhiều”.
        
    * Với quan hệ N-N: tạo bảng trung gian (ví dụ: order\_items) chứa khóa ngoại của hai bảng liên quan, và có thể thêm các thuộc tính riêng (quantity, unit\_price)
        
4. Thứ tự tạo bảng trong DBMS
    
    * Nên tạo các bảng không phụ thuộc (products, customers, shippers, order\_statuses) trước vì chúng không có khóa ngoại, nên có thể tạo độc lập mà không gặp lỗi ràng buộc dữ liệu. Sau đó mới tạo các bảng có khóa ngoại như orders và order\_items, vì các bảng này cần tham chiếu đến các bảng đã có sẵn để đảm bảo toàn vẹn dữ liệu và tránh lỗi khi định nghĩa khóa ngoại[.](https://tecadmin.net/creating-a-table-with-foreign-keys-in-mysql/)[  
        ](https://airbyte.com/data-engineering-resources/database-schema-examples)Làm như vậy giúp quá trình tạo bảng diễn ra suôn sẻ và đảm bảo các mối liên kết giữa bảng được thiết lập chính xác ngay từ đầu.
        

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750036488459/6fd745f3-03c5-4513-a4a7-7e4829a927cc.png align="center")

5. **Tạo bảng bằng lệnh SQL**:  
    Các slide trình bày ví dụ lệnh SQL tạo bảng cho từng entity, xác định kiểu dữ liệu, ràng buộc NOT NULL, AUTO\_INCREMENT, PRIMARY KEY, FOREIGN KEY, v.v
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750036527181/dc0440ea-1e46-44c5-bb2a-b00bd7dfefdd.png align="center")

## Database Normalization – Chuẩn hóa dữ liệu trong thiết kế CSDL

## [1](https://bhk.vn/chuan-hoa-co-so-du-lieu-dinh-nghia-va-phan-loai/). Chuẩn hóa dữ liệu là gì?

Chuẩn hóa dữ liệu (database normali[z](https://bhk.vn/chuan-hoa-co-so-du-lieu-dinh-nghia-va-phan-loai/)ation) là quá trình tổ chức [d](https://bhk.vn/chuan-hoa-co-so-du-lieu-dinh-nghia-va-phan-loai/)ữ liệu trong cơ sở dữ liệu nhằm loại bỏ dư thừa, giảm trùng lặp và đảm bảo tính toàn vẹn dữ li[ệu](https://viblo.asia/p/dbms-normalization-easy-chuan-hoa-trong-thiet-ke-database-relationship-n1j4lOrAVwl). Quá trình này chia các bảng lớn thành các bảng nhỏ hơn, li[ê](https://viblo.asia/p/dbms-normalization-easy-chuan-hoa-trong-thiet-ke-database-relationship-n1j4lOrAVwl)[n](https://funix.edu.vn/chia-se-kien-thuc/chuan-hoa-cac-quan-he-ve-cac-dang-chuan-co-ban/) kết với nhau qua các mối q[u](https://viblo.asia/p/dbms-normalization-easy-chuan-hoa-trong-thiet-ke-database-relationship-n1j4lOrAVwl)[a](https://funix.edu.vn/chia-se-kien-thuc/chuan-hoa-cac-quan-he-ve-cac-dang-chuan-co-ban/)n hệ, giúp dữ liệu dễ bảo trì, truy vấn hiệu quả và hạn chế lỗi khi cập nhật

## 2\. Vì sao cần chuẩn hóa?

Nếu không chuẩn hóa, cơ sở dữ liệu dễ gặp các bất thường (anomaly):

* **Update anomaly:** Khi cập nhật một thông tin lặp ở nhiều nơi, nếu sót sẽ gây sai lệch dữ liệu.
    
* **Insert anomaly:** Không thể thêm dữ liệu mới nếu thiếu thông tin ở cột khác (ví dụ, muốn thêm môn học mới nhưng chưa có sinh viên đăng ký).
    
* **Delete anomaly:** Xóa một dòng có thể vô tình làm mất thông tin quan trọng khác (ví dụ, xóa sinh viên cuối cùng học một môn sẽ mất luôn thông tin về môn đó
    

## 3\. Các dạng chuẩn hóa cơ bản

## a. Dạng chuẩn 1NF (First Normal Form)

* **Yêu cầu:** Mỗi ô chỉ chứa một giá trị nguyên tử, không có nhóm lặp, mỗi hàng là duy nhất
    
* **Ví dụ:** Một bảng có cột số điện thoại, mỗi ô chỉ chứa một số, không phải danh sách nhiều số.
    

**Minh họa:**

* Trước:
    
    | **StudentID** | **Name** | **Phone** |
    | --- | --- | --- |
    | 101 | Vinh | 19001080,19001081 |
    
* Sau:
    
    | **StudentID** | **Name** | **Phone** |
    | --- | --- | --- |
    | 101 | Vinh | 19001080 |
    | 101 | Vinh | 19001081 |
    

## b. Dạng chuẩn 2NF (Second Normal Form)

* **Yêu cầu:** Đạt 1NF và mọi thuộc tính không khóa phải phụ thuộc hoàn toàn vào khóa chính (loại bỏ phụ thuộc từng phần)
    
* **Áp dụng:** Thường gặp khi bảng có khóa chính phức hợp (composite key).
    
* **Ví dụ:**
    
    * Trước:
        
        | **OrderID** | **ProductID** | **ProductName** | **Quantity** |
        | --- | --- | --- | --- |
        | 1 | 101 | Laptop | 2 |
        
        * Ở đây, ProductName chỉ phụ thuộc vào ProductID, không phải vào cả OrderID và ProductID.
            
    * Sau:
        
        * Tách thành hai bảng:
            
            | **OrderID** | **ProductID** | **Quantity** |
            | --- | --- | --- |
            | 1 | 101 | 2 |
            | ProductID | ProductName |  |
            | \----------- | \------------- |  |
            | 101 | Laptop |  |
            

c. Dạng chuẩn 3NF (Third Normal Form)

* **Yêu cầu:** Đạt 2NF và không có phụ thuộc bắc cầu (transitive dependency) giữa các thuộc tính không khóa.
    
* **Giải thích:** Mọi thuộc tính không khóa chỉ phụ thuộc vào khóa chính, không phụ thuộc qua một thuộc tính khác.
    
* **Ví dụ:**
    
    * Trước:
        
        | **StudentID** | **Name** | **Zipcode** | **City** |
        | --- | --- | --- | --- |
        | 1 | Vinh | 94000 | CanTho |
        
        * City phụ thuộc vào Zipcode, Zipcode phụ thuộc vào StudentID.
            
    * Sau:
        
        * Tách thành hai bảng:
            
            | **StudentID** | **Name** | **Zipcode** |
            | --- | --- | --- |
            | 1 | Vinh | 94000 |
            | Zipcode | City |  |
            | \--------- | \-------- |  |
            | 94000 | CanTho |  |
            

## d. Dạng chuẩn BCNF, 4NF, 5NF

## **BCNF (Boyce–Codd Normal Form)**

* **Định nghĩa:**  
    Một bảng đạt chuẩn BCNF nếu với mọi phụ thuộc hàm X → Y, thì X là siêu khóa của bảng đó.  
    Nói cách khác, mọi phụ thuộc hàm không tầm thường đều phải có vế trái là siêu khóa.
    
* **Ý nghĩa:**  
    BCNF là phiên bản chặt hơn của 3NF, loại bỏ các trường hợp ngoại lệ mà 3NF chưa xử lý hết, đặc biệt với các bảng có nhiều candidate key hoặc phụ thuộc hàm phức tạp.
    
* **Ví dụ:**  
    Giả sử bảng đăng ký môn học:
    
    | **StudentID** | **CourseID** | **InstructorID** | **InstructorName** |
    | --- | --- | --- | --- |
    | 101 | CS101 | I01 | John Smith |
    | 102 | CS101 | I01 | John Smith |
    | 103 | MA201 | I02 | Alice Brown |
    
    * Phụ thuộc: InstructorID → CourseID, InstructorID → InstructorName.
        
    * Candidate key: (StudentID, CourseID) và (StudentID, InstructorID).
        
    * InstructorID không phải là siêu khóa, nên bảng này vi phạm BCNF và cần tách thành hai bảng:
        
        * Đăng ký: (StudentID, InstructorID)
            
        * Giảng viên: (InstructorID, CourseID, InstructorName)
            

## **4NF (Fourth Normal Form)**

* **Định nghĩa:**  
    Một bảng đạt 4NF nếu:
    
    * Đã đạt BCNF.
        
    * Không có phụ thuộc đa trị phi tầm thường mà vế trái không phải là siêu khóa.
        
* **Phụ thuộc đa trị (multivalued dependency):**  
    Xảy ra khi một thuộc tính có thể có nhiều giá trị độc lập với các thuộc tính khác trong cùng bảng.
    
* **Ví dụ:**  
    Bảng lưu thông tin sinh viên, các môn học và sở thích:
    
    | **StudentID** | **Course** | **Hobby** |
    | --- | --- | --- |
    | 1 | Math | Basketball |
    | 1 | Math | Reading |
    | 1 | Science | Basketball |
    | 1 | Science | Reading |
    
    * Ở đây, StudentID quyết định độc lập cả Course và Hobby → phụ thuộc đa trị.
        
    * Để đạt 4NF, tách thành hai bảng:
        
        * Student\_Courses(StudentID, Course)
            
        * Student\_Hobbies(StudentID, Hobby)
            

## **5NF (Fifth Normal Form)**

* **Định nghĩa:**  
    Một bảng đạt 5NF nếu:
    
    * Đã đạt 4NF.
        
    * Mọi phép phân rã (decomposition) của bảng thành các bảng con đều là phân rã không mất mát (lossless join), nghĩa là khi nối lại không bị mất hoặc tạo ra dữ liệu sai.
        
* **Ý nghĩa:**  
    5NF xử lý các quan hệ phức tạp hơn, đảm bảo dữ liệu không bị lặp lại hoặc mất mát khi phân rã bảng nhiều chiều.
    
* **Ví dụ:**  
    Bảng lưu thông tin Dealer, Product, Supplier:
    
    | **Dealer** | **Product** | **Supplier** |
    | --- | --- | --- |
    | D1 | P1 | S1 |
    | D1 | P2 | S1 |
    | D2 | P1 | S1 |
    | D2 | P2 | S2 |
    | D1 | P1 | S2 |
    | D2 | P1 | S2 |
    
    * Nếu tồn tại các phụ thuộc join phức tạp, cần phân rã thành các bảng nhỏ hơn (Dealer-Product, Product-Supplier, Dealer-Supplier) để đảm bảo khi join lại vẫn đúng dữ liệu gốc, không dư thừa hoặc thiếu thông tin.
        

## 4\. Quy trình chuẩn hóa thực tế

**Bước 1: Kiểm tra bảng đã đạt 1NF chưa (cột lặp, giá trị không nguyên tử)**

* Đảm bảo mỗi cột chỉ chứa một giá trị duy nhất (nguyên tử), không có danh sách, mảng hoặc nhóm lặp trong một ô.
    
* Nếu phát hiện cột chứa nhiều giá trị (ví dụ: số điện thoại tách bằng dấu phẩy), cần tách thành nhiều dòng hoặc bảng riêng.
    

**Bước 2: Xem xét phụ thuộc từng phần để chuẩn hóa lên 2NF**

* Kiểm tra các bảng có khóa chính phức hợp (nhiều cột).
    
* Loại bỏ các thuộc tính không khóa chỉ phụ thuộc vào một phần của khóa chính, tách chúng ra bảng riêng để đảm bảo mọi thuộc tính không khóa đều phụ thuộc hoàn toàn vào toàn bộ khóa chính.
    

**Bước 3: Xem xét phụ thuộc bắc cầu để chuẩn hóa lên 3NF**

* Kiểm tra xem có thuộc tính không khóa nào phụ thuộc vào một thuộc tính không khóa khác không (phụ thuộc bắc cầu).
    
* Nếu có, tách các thuộc tính này sang bảng mới để đảm bảo mọi thuộc tính không khóa chỉ phụ thuộc trực tiếp vào khóa chính.
    

**Bước 4: Nếu cần, tiếp tục chuẩn hóa lên BCNF, 4NF, 5NF**

* Xác định các phụ thuộc hàm phức tạp mà 3NF chưa xử lý hết (BCNF).
    
* Kiểm tra và loại bỏ các phụ thuộc đa trị (4NF), đảm bảo không có thuộc tính nào độc lập nhận nhiều giá trị cho một khóa.
    
* Nếu bảng có các quan hệ phức tạp, phân rã thêm để đảm bảo khi ghép các bảng con lại không mất mát dữ liệu (5NF).
    

## 5\. Lưu ý khi chuẩn hóa

* **Không phải lúc nào cũng cần chuẩn hóa tối đa**: Đôi khi, để tối ưu hiệu năng truy vấn (OLAP), có thể chấp nhận phi chuẩn hóa một số bảng.
    
* Chuẩn hóa giúp dữ liệu nhất quán, dễ bảo trì, giảm lỗi khi cập nhật.
    

Trong thời đại phát triển phần mềm hiện đại, quản lý phiên bản (version control) là công cụ không thể thiếu để kiểm soát và cộng tác hiệu quả trên các dự án code. Dù bạn là lập trình viên cá nhân hay thành viên của một nhóm lớn, hiểu và sử dụng Git cùng GitHub sẽ giúp bạn làm chủ quá trình phát triển, bảo vệ lịch sử dự án và làm việc nhóm dễ dàng hơn.

# **M01W02 - \[v2\] Advanced Data Structure (IoU, NMS, and Histogram)**

## Tuple in Python

Do you know what a data structure is? A data structure is a system used to store and organize data. It arranges data on a computer so it can be accessed and updated efficiently.

## 1D List Solution

Dr. Nguyen presents a math problem where you use Python to create a list of about 6 students in a class. You need to check their seating arrangement, which is organized in 3 rows and 2 columns. This **1D List Solution** means you solve the problem using only a basic list in Python, not a matrix.

You have 6 students:

```css
["Vinh", "An", "Toan", "Lam", "Tam", "Chuyen"]
```

They sit in **3 rows** and **2 columns**, from top to bottom, left to right:

```sql
Row 1: Vinh   | An
Row 2: Toan   | Lam
Row 3: Tam    | Chuyen
       Col 1    Col 2
```

Dr. Nguyen suggests a solution for this problem using an algorithm that can be difficult for beginners. He uses two examples, Tam and Chuyen, to explain this solution. This is a classic 2D-to-1D indexing problem that you can solve using Python.

```python
# List of students arranged row-wise
student_list = ["Vinh", "An", "Toan", "Lam", "Tam", "Chuyen"]

# Dimensions of the classroom
row_class = 3
col_class = 2

# Function to find the student at a given (row, column)
def find_student(student_list, r, c):
    index = (r - 1) * col_class + (c - 1)
    return student_list[index]

# Find student at location (3, 1)
print(find_student(student_list, 3, 1))  # Output: Tam

# Find student at location (3, 2)
print(find_student(student_list, 3, 2))  # Output: Chuyen
```

The key part of this solution is the algorithm for calculating the **index** in the **find\_student** function. It shows how we convert from 2D to 1D using simple math to solve the problem.

To get the student at row `r` and column `c`, you calculate the index in the list with the formula:

```python
index = (r - 1) * col_class + (c - 1)
```

The formula moves us row by row:

* Row 1: starts at index 0 → positions 0, 1
    
* Row 2: starts at index 2 → positions 2, 3
    
* Row 3: starts at index 4 → positions 4, 5
    

Using `(r - 1) * col_class` helps us skip whole rows, and `(c - 1)` picks the seat in the row.

| **Example** | **Result** | **Analysis** |
| --- | --- | --- |
| `find_student(student_list, 3, 1)` | Tam | Row 1: starts at index 0 |
| `find_student(student_list, 3, 2)` | Chuyen | Row 2: starts at index 2 |
| `find_student(student_list, 2, 1)` | Toan | Row 3: starts at index 4 |
| `find_student(student_list, row, col)` |  | Row 1 index: `(1 - 1) * 2 = 0` |
|  |  | Row 2 index: `(2 - 1) * 2 = 2` |
|  |  | Row 3 index: `(3 - 1) * 2 = 4` |
| `find_student(student_list, 3, 1)` | Tam | `Index = (3 - 1) * 2 + (1 - 1) = 4` |
| `find_student(student_list, 3, 2)` | Chuyen | `Index = (3 - 1) * 2 + (2 - 1) = 5` |

You can see that it can be challenging for people using Python or learning data structures for the first time. Dr. Nguyen will teach you a **2D List Solution** that is much easier and more understandable for everyone, similar to algebra.

## 2D List Solution

Dr. Nguyen suggests using a 3x**1D List** in one list instead of just a **1D list** for all.

Instead of one giant list, you can structure each row as a 1D list:

```python
row1_student = ["Vinh", "An"]
row2_student = ["Toan", "Lam"]
row3_student = ["Tam", "Chuyen"]
```

Then, we combine them into a 2D list:

```python
student_list = [row1_student, row2_student, row3_student]
```

### 2D List

* Easy to visualize and manage tabular data.
    
* Helps with real-world mapping: seating plans, spreadsheets, matrices, etc.
    
* Provides clean indexing for accessing or updating values.
    

And by combining all of this, you will have a program to solve this problem more easily.

```python
# Step 1: Define each row as a 1D list
row1_student = ["Vinh", "An"]
row2_student = ["Toan", "Lam"]
row3_student = ["Tam", "Chuyen"]

# Step 2: Combine rows into a 2D list
student_list = [row1_student, row2_student, row3_student]

# Step 3: Define a function to find a student at row r and column c (1-based indexing)
def find_student(student_list, r, c):
    return student_list[r - 1][c - 1]

# Step 4: Use the function to find students
print(find_student(student_list, 3, 1))  # Output: Tam
print(find_student(student_list, 3, 2))  # Output: Chuyen
```

## Python Basics: Mutable vs. Immutable

In Python, everything is treated as an **object**. Each object has three core attributes:

* **Identity**: The memory address (where it's stored)
    
* **Type**: The kind of object (e.g., list, string, int)
    
* **Value**: The actual data stored in the object
    

Understanding the difference between **mutable** and **immutable** types is essential for writing reliable and efficient Python code.

|  | **Mutable** | **Immutable** |
| --- | --- | --- |
| Can change value? | ✅ Yes | ❌ No |
| Examples | List, Dictionary, Set | String, Tuple, Integer |

### **Lists Are Mutable**

Mutable objects like **lists** can have their content changed **without changing their identity**.

```python
list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
print("original list")
print(list)

# Change value at index 4
list[4] = 'hello'
print("changed list")
print(list)
#original list
#['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
#changed list
#['a', 'b', 'c', 'd', 'hello', 'f', 'g', 'h']
```

### **Strings Are Immutable**

Immutable objects like **strings** **cannot be changed** after creation.

```python
words = "AI is trending"
words[3] = 'e'  # Attempt to change character at index 3
#TypeError: 'str' object does not support item assignment
```

### **Memory Address Check**

List (Mutable):

```python
list1 = [1, 2, 3, 4, 5]
list2 = [1, 2, 3, 4, 5]

print(id(list1))  # Memory address of list1
print(id(list2))  # Memory address of list2
#Different between 2 ID
```

String (Immutable):

```python
str1 = "AI2024"
str2 = "AI2024"

print(id(str1))  # Memory address of str1
print(id(str2))  # Memory address of str2
# Two ID are the same
```

Conclusion:

| Feature | Mutable (e.g., List) | Immutable (e.g., String) |
| --- | --- | --- |
| Can change value? | ✅ Yes | ❌ No (new object is created) |
| Memory behavior | New object → new memory address | Identical values may share memory address |

## Tuple Motivation And Definition of Tuple

### **Definition**

Tuple are another kind of sequence that functions much like a list - they have elements which are indexed starting at 0. Unlike a list, once you create a tuple, you cannot alter its contents - similar to a string.

| Feature | Tuple | List |
| --- | --- | --- |
| Mutable | ❌ No | ✅ Yes |
| Faster | ✅ Yes | ❌ No |
| Hashable | ✅ (if elements are) | ❌ No |
| Safe for configs | ✅ Yes | ❌ No |
| Can be dict key | ✅ Yes | ❌ No |

### **Structure**

```python
 tuple_name = (element-1, …, element-n)
```

When you use a tuple, you can use many functions in Python like **len(), zip(), sorted(), etc.**

### **Tuple Examples**

* Swapping two variables
    
    ```python
    def swap(v1, v2):
        (v2, v1) = (v1, v2)
        return (v1, v2)
    
    v1 = 2
    v2 = 3
    (v1, v2) = swap(v1, v2)
    
    print(v1)
    print(v2)
    ```
    
* Memory requirement
    
    ```python
    # memory comparison
    import sys
    alist = [3, 4, 5, 6, 7]
    aTuple = (3, 4, 5, 6, 7)
    
    print(sys.getsizeof(alist))
    print(sys.getsizeof(aTuple))
    ```
    
* Tuple slicing
    
    ```python
    data = (1, 2, 3, 4, 5)
    print(data[2:])  # (3, 4, 5)
    ```
    
* List2tuple
    
    ```python
    # convert from list to tuple
    alist = [3, 4, 5, 6, 7]
    aTuple = tuple(alist)
    
    print(aTuple)
    print(type(aTuple))  # <class 'tuple'>
    ```
    
* Tuple2list
    
    ```python
    # convert from tuple to list
    aTuple = (3, 4, 5, 6, 7)
    alist = list(aTuple)
    
    print(alist)
    print(type(alist))  # <class 'list'>
    ```
    

### **Example: Solve quadratic equation**

```python
import math

def quadratic_equation(a, b, c):
    # This function solves the quadratic equation
    # a, b, c -- three parameters and a != 0
    # compute delta
    delta = b*b - 4*a*c

    if delta < 0:
        return ()
    elif delta == 0:
        x = (-b)/(2*a)
        return (x,)
    else:
        x1 = (-b + math.sqrt(delta))/(2*a)
        x2 = (-b - math.sqrt(delta))/(2*a)
        return (x1, x2)

# Case 1: delta > 0
result = quadratic_equation(1, -5, 6)
print(result)  # (3.0, 2.0)
print(type(result))  # <class 'tuple'>

# Case 2: delta = 0
result = quadratic_equation(1, 2, 1)
print(result)  # (-1.0,)
print(type(result))  # <class 'tuple'>

# Case 3: delta < 0
result = quadratic_equation(1, 1, 1)
print(result)  # ()
print(type(result))  # <class 'tuple'>

# Data is protected
result = quadratic_equation(1, 1, 1)
```

## Set Motivation in Python

## Definition

Sets, unlike lists or tuples, do not allow duplicate elements and store values in no particular order.

## What you can do?

### Create a set

* Using curly brackets
    
    ```python
    # create a set
    animals = {"cat", "dog", "tiger"}
    print(type(animals))
    # <class 'set'>
    ```
    
* Items with different data types
    
    ```python
    # a set
    a = {"cat", 5, True, 40.0}
    print(type(a))
    # <class 'set'>
    ```
    
* Set comprehension
    
    ```python
    # a set comprehension
    a_set = {i * i for i in range(10)}
    print(a_set)
    # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}
    ```
    
* Access the items of a set
    
    ```python
    # accessing the items of a set
    animals = {"cat", "dog", "tiger"}
    for animal in animals:
        print(animal)
    # dog
    # cat
    # tiger
    ```
    
* Copy a set
    
    ```python
    # copy a set
    animals = {"cat", "dog", "tiger"}
    print(animals)  # animals
    a_copy = animals.copy()
    print(a_copy)  # a_copy
    # Animals: {'dog', 'cat', 'tiger'}
    # Copy: {'dog', 'cat', 'tiger'}
    ```
    
* Add an item
    
    ```python
    # add an item
    animals = {"cat", "dog", "tiger"}
    animals.add("bear")
    print(animals)
    # {'dog', 'bear', 'cat', 'tiger'}
    ```
    
* Insert a set to another set
    
    ```python
    # insert a set into another set
    animals = {"cat", "dog", "tiger"}
    animals.update({"chicken", "duck"})
    print(animals)
    # {'Duck', 'tiger', 'dog', 'cat', 'chicken'}
    ```
    
* Join two sets
    
    ```python
    # join two sets
    set1 = {"duck", "dog"}
    set2 = {"cat", "tiger"}
    set3 = set1.union(set2)
    print(set3)
    # {'duck', 'dog', 'cat', 'tiger'}
    ```
    
* Not allow duplicate values
    
    ```python
    # no duplication
    animals = {"cat", "dog", "tiger"}
    animals.add("cat")
    print(animals)
    # {'tiger', 'cat', 'dog'}
    ```
    
* Difference function
    
    ```python
    # difference function
    set1 = {"apple", "banana", "cherry"}
    set2 = {"pineapple", "apple"}
    set3 = set1.difference(set2)
    print(set3)
    # {'cherry', 'banana'}
    ```
    
* Symmetric\_difference
    
    ```python
    # symmetric difference
    set1 = {"apple", "banana", "cherry"}
    set2 = {"pineapple", "apple"}
    set3 = set1.symmetric_difference(set2)
    print(set3)
    # {'pineapple', 'cherry', 'banana'}
    ```
    
* Difference\_update function
    
    ```python
    # difference update function
    set1 = {"apple", "banana", "cherry"}
    set2 = {"pineapple", "apple"}
    set1.difference_update(set2)
    print(set1)
    # {'cherry', 'banana'}
    ```
    
* Symmetric\_difference\_update
    
    ```python
    # symmetric difference update
    set1 = {"apple", "banana", "cherry"}
    set2 = {"pineapple", "apple"}
    set1.symmetric_difference_update(set2)
    print(set1)
    # {'pineapple', 'cherry', 'banana'}
    ```
    
* Unordered and unindexed
    
    ```python
    # not support indexing
    animals = {"cat", "dog", "tiger"}
    print(animals[1])  # Raises TypeError
    # TypeError: 'set' object is not subscriptable
    ```
    
* Cannot contain unhashable types
    
    ```python
    # create a set
    a_list = [1, 2, 3]
    a_set = {"cat", a_list}  # Raises TypeError
    print(a_set)
    # TypeError: unhashable type: 'list'
    ```
    

### Bitwise operator

* AND
    
    ```python
    # AND (&)
    set1 = {1, 2, 3}
    set2 = {3, 4, 5}
    print(set1 & set2)
    # {3}
    ```
    
* XOR
    
    ```python
    # XOR (^)
    set1 = {1, 2, 3}
    set2 = {3, 4, 5}
    print(set1 ^ set2)
    # {1, 2, 4, 5}
    ```
    
* OR
    
    ```python
    # OR (|)
    set1 = {1, 2, 3}
    set2 = {3, 4, 5}
    print(set1 | set2)
    # {1, 2, 3, 4, 5}
    ```
    
* SUBTRACTION
    
    ```python
    # subtraction (-)
    set1 = {1, 2, 3}
    set2 = {3, 4, 5}
    print(set1 - set2)
    # {1, 2}
    ```
    

### Remove an item

Instead of using remove, you must use discard when working with a set which item is not contained in this set

* remove(item)
    
    ```python
    # remove an item
    animals = {"cat", "dog", "tiger"}
    animals.remove("cat")
    print(animals)
    # {'dog', 'tiger'}
    ```
    
* discard(item)
    
    ```python
    # remove an item from the set if it is present
    animals = {"cat", "dog", "tiger"}
    animals.discard("tiger")
    print(animals)
    # {'dog', 'cat'}
    ```
    
* Set comprehension
    
    ```python
    # a set comprehension
    a_set = {i for i in range(10)}
    print(a_set)
    # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    ```
    
* remove(item)  
    Remove an item from the set.  
    Raises KeyError if elem is not contained in the set.
    
    ```python
    # remove an item
    animals = {"cat", "dog", "tiger"}
    animals.remove("duck")  # Raises KeyError if 'duck' is not in the set
    print(animals)
    # KeyError: 'duck'
    ```
    
* discard(item)  
    Remove an item from the set if it is present.
    
    ```python
    # remove an item from the set if it is present
    animals = {"cat", "dog", "tiger"}
    animals.discard("duck")
    print(animals)
    # {'dog', 'cat', 'tiger'}
    ```
    

### Set to List and Tuple

* Set to List
    
    ```python
    # convert from set to list
    aSet = {1, 2, 3, 4, 5}
    aList = list(aSet)
    print(aList)
    print(type(aList))
    # [1, 2, 3, 4, 5]
    # <class 'list'>
    ```
    
* List to Set
    
    ```python
    # convert from list to set
    aList = [1, 2, 3, 2, 1]
    aSet = set(aList)
    print(aSet)
    print(type(aSet))
    # {1, 2, 3}
    # <class 'set'>
    ```
    
* Set to Tuple
    
    ```python
    # convert from set to tuple
    aSet = {1, 2, 3, 4, 5}
    aTuple = tuple(aSet)
    print(aTuple)
    print(type(aTuple))
    # (1, 2, 3, 4, 5)
    # <class 'tuple'>
    ```
    
* Tuple to Set
    
    ```python
    # convert from tuple to set
    aTuple = (1, 2, 3, 2, 1)
    aSet = set(aTuple)
    print(aSet)
    print(type(aSet))
    # {1, 2, 3}
    # <class 'set'>
    ```
    

## Dictionary in Python

## Definition

A dictionary in Python is a built-in data structure that stores data as key-value pairs. It's an unordered, mutable collection where each element consists of a unique key and its associated value.

## Structure

Dictionaries use curly braces `{}` and store data in the format `{key: value, key: value, ...}`

```python
 dictionary_name = {key-1:value-1, …, key-n:value-n}
```

**Key Properties**:

* Keys must be unique and immutable (strings, numbers, tuples)
    
* Values can be of any data type and can be duplicated
    
* Dictionaries are mutable (can be modified after creation)
    
* As of Python 3.7+, dictionaries maintain insertion order
    

## Comparing between List and Dictionary

| **Aspect** | **Lists** | **Dictionaries** |
| --- | --- | --- |
| **Keys/Indices** | Numeric indices only | Any immutable type (strings, numbers, tuples) |
| **Duplicates** | Values can be duplicated | Keys must be unique, values can be duplicated |
| **Performance** | O(n) for searching | O(1) average for key lookup |
| **Use Case** | Sequential data, ordered collections | Mappings, lookups, related data |

**Use Lists when**:

* You need ordered data
    
* Working with sequences
    
* Indices have meaning (like time series)
    
* Need to maintain duplicates
    

**Use Dictionaries when**:

* You need fast lookups
    
* Data has natural key-value relationships
    
* Keys are more meaningful than positions
    
* Building mappings or associations
    

## What you can do?

### Create a Dictionary

* Dictionary comprehension
    
    ```python
    # dic comprehension
    a_dict = {i: i * i for i in range(5)}
    print(a_dict)
    # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
    ```
    
* From zip
    
    ```python
    # from zip
    tuple1 = (1, 2, 3)
    tuple2 = (4, 5, 6)
    a_dict = dict(zip(tuple1, tuple2))
    print(a_dict)
    # {1: 4, 2: 5, 3: 6}
    ```
    
* From zip (alternative)
    
    ```python
    # from zip
    list1 = [1, 2, 3]
    list2 = [4, 5, 6]
    a_dict = dict(zip(list1, list2))
    print(a_dict)
    # {1: 4, 2: 5, 3: 6}
    ```
    
* From zip
    
    ```python
    # from zip
    set1 = {1, 2, 3}
    set2 = {4, 5, 6}
    a_dict = dict(zip(set1, set2))
    print(a_dict)
    # {1: 4, 2: 5, 3: 6}
    ```
    

### Update a value

```python
# update a value
parameters = {"learning_rate": 0.1, "metric": "Accuracy"}
parameters["learning_rate"] = 0.2
print(parameters)
# {'learning_rate': 0.2, 'metric': 'Accuracy'}
```

### Copy a dictionary

```python
# copy a dictionary
parameters = {"learning_rate": 0.1, "metric": "Accuracy"}
a_copy = parameters.copy()
print(a_copy)
# {'learning_rate': 0.1, 'metric': 'Accuracy'}
```

### Copy() function just only copy shallow type

```python
# shallow copy
d1 = {"a": [1, 2], "b": 1}
d2 = d1.copy()
# thay đổi d1 sẽ không ảnh hưởng đến d2
d1["a"][0] = 3
print(d1)  # {'a': [3, 2], 'b': 1}
print(d2)  # {'a': [3, 2], 'b': 1}
```

### Using deepcopy() function in module copy

```python
# using deepcopy
import copy
d1 = {"a": [1, 2], "b": 1}
d2 = copy.deepcopy(d1)
d1["a"][0] = 3
print(d1)  # {'a': [3, 2], 'b': 1}
print(d2)  # {'a': [1, 2], 'b': 1}
```

### Get keys and values

* Get keys
    
    ```python
    # Get keys
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    keys = parameters.keys()
    print(keys)
    # dict_keys(['learning_rate', 'optimizer', 'metric'])
    ```
    
* Get values
    
    ```python
    # Get values
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    values = parameters.values()
    print(values)
    # dict_values([0.1, 'Adam', 'Accuracy'])
    ```
    
* Get keys and values
    
    ```python
    # Get keys and values
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    items = parameters.items()
    for key, value in items:
        print(key, value)
    # learning_rate 0.1
    # optimizer Adam
    # metric Accuracy
    ```
    

### Get a value by a key

* Get value using get() function
    
    ```python
    # Get value using get() function
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    value = parameters.get("learning_rate")
    print(value)
    print("After using get() function:")
    print(parameters)
    # 0.1
    # After using get() function:
    # {'learning_rate': 0.1, 'optimizer': 'Adam', 'metric': 'Accuracy'}
    ```
    
* Get value and delete the corresponding item
    
    ```python
    # Get value and delete the corresponding item
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    value = parameters.pop("learning_rate")
    print(value)
    print("After using pop() function:")
    print(parameters)
    # 0.1
    # After using pop() function:
    # {'optimizer': 'Adam', 'metric': 'Accuracy'}
    ```
    

### Dictionary operations

* popitem()
    
    ```python
    # popitem() - Lấy ra một phần tử cuối cùng của dictionary
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    item = parameters.popitem()
    print(item)
    print(parameters)
    # ('metric', 'Accuracy')
    # {'learning_rate': 0.1, 'optimizer': 'Adam'}
    ```
    
* clear()
    
    ```python
    # clear() - Xóa tất cả các phần tử trong dictionary
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    print("Before using clear() function:")
    print(parameters)
    parameters.clear()
    print("After using clear() function:")
    print(parameters)
    # Before using clear() function:
    # {'learning_rate': 0.1, 'optimizer': 'Adam', 'metric': 'Accuracy'}
    # After using clear() function:
    # {}
    ```
    
* Use del keyword to delete an item
    
    ```python
    # Use del keyword to delete an item
    parameters = {"learning_rate": 0.1, "metric": "Accuracy"}
    print(parameters)
    del parameters["metric"]
    print(parameters)
    # {'learning_rate': 0.1, 'metric': 'Accuracy'}
    # {'learning_rate': 0.1}
    ```
    

### Key that does not exist

* Try to delete a non-existing item
    
    ```python
    # Try to delete a non-existing item
    parameters = {"learning_rate": 0.1, "metric": "Accuracy"}
    del parameters["algorithm"]
    # KeyError: 'algorithm'
    ```
    
* Try to get an item by a non-existing key
    
    ```python
    # Try to get an item by a non-existing key
    parameters = {"learning_rate": 0.1, "optimizer": "Adam", "metric": "Accuracy"}
    value = parameters.pop("algorithm")
    # KeyError: 'algorithm'
    ```
    
* Setdefault() function
    
    * Example 1
        
        ```python
        # setdefault() function
        fruits = {"banana": 2}
        fruits.setdefault("apple", 0)
        print(fruits)
        # {'banana': 2, 'apple': 0}
        ```
        
    * Example 2
        
        ```python
        # setdefault() function
        fruits = {"banana": 2, "apple": 4}
        fruits.setdefault("apple", 0)
        print(fruits)
        # {'banana': 2, 'apple': 4}
        ```
        
    * Example 3
        
        ```python
        # setdefault() function
        fruits = {"banana": 2}
        fruits["apple"] += 10
        print(fruits)
        # KeyError: 'apple'
        ```
        
    * Example 4
        
        ```python
        # setdefault() function
        fruits = {"banana": 2}
        fruits.setdefault("apple", 0)
        fruits["apple"] += 10
        print(fruits)
        # {'banana': 2, 'apple': 10}
        ```
        

### Get a value via a key

* Method 1
    
    ```python
    # access value via key
    fruits = {"banana": 2, "apple": 4}
    print(fruits["apple"])
    print(fruits["corn"])
    # 4
    # KeyError: 'corn'
    ```
    
* Method 2
    
    ```python
    # access value via key
    fruits = {"banana": 2, "apple": 4}
    print(fruits.get("apple"))
    print(fruits.get("corn"))
    # 4
    # None
    ```
    
* Merge two dictionaries
    
    ```python
    # merge two dicts
    fruits = {"banana": 2, "apple": 4}
    cereal = {"rice": 3, "corn": 7}
    result = {**fruits, **cereal}
    print(result)
    # {'banana': 2, 'apple': 4, 'rice': 3, 'corn': 7}
    ```
    
* Check if a key exists
    
    ```python
    # check if a key exists
    fruits = {"banana": 2, "apple": 4}
    print("apple" in fruits)
    print("corn" in fruits)
    # True
    # False
    ```
    
* Remove empty items
    
    ```python
    # remove empty items
    fruits = {"banana": 2, "apple": None}
    dict1 = {key: value for (key, value) in fruits.items() if value is not None}
    print(dict1)
    # {'banana': 2}
    ```
    
* Dictionary comprehension
    
    ```python
    # dic comprehension
    aDict = {str(i): i for i in range(5)}
    print(aDict)
    # {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4}
    ```
    

## Conclusion

In conclusion, understanding the various data structures in Python, such as tuples, sets, and dictionaries, is crucial for efficient data management and manipulation. Each data structure has its unique properties and use cases.

Tuples are immutable and can be used as keys in dictionaries, making them suitable for configurations and ensuring data integrity.

Sets are ideal for operations involving unique elements and provide efficient methods for set operations like union and intersection.

Dictionaries offer a flexible way to store key-value pairs, allowing for fast lookups and data retrieval. By mastering these data structures, you can write more efficient and effective Python code, tailored to the specific needs of your applications.

*Reference source (original document):* [Documents/2025-5/M01W02 - \[v2\] Advanced Data Structure (IoU, NMS, and Histogram)/AIO2025\_AdvancedDataStructure\_v2.pdf](https://aivnlearning.edu.vn/api/files/68317576519c0e157fb51481/Documents%2F2025-5%2FM01W02%20-%20%5Bv2%5D%20Advanced%20Data%20Structure%20\(IoU%2C%20NMS%2C%20and%20Histogram\)%2FAIO2025_AdvancedDataStructure_v2.pdf)

# M01W02T7: Git & GitHub For Version Control

## I. Version Control là gì?

Hãy tưởng tượng bạn xây một ngôi nhà, mỗi lần thay đổi gì đó, bạn chụp lại một bức ảnh để nếu có vấn đề, bạn có thể quay lại trạng thái trước đó. Version control cũng giống như vậy với code: nó lưu lại mọi “bức ảnh” của dự án sau mỗi lần thay đổi, cho phép bạn quay lại bất kỳ thời điểm nào nếu cần.

## **Lợi ích của Version Control:**

* ## Theo dõi toàn bộ lịch sử thay đổi của dự án.
    
* Biết ai, khi nào và tại sao thay đổi gì.
    
* Dễ dàng hoàn tác (revert) về phiên bản ổn định nếu gặp lỗi.
    
* Hỗ trợ làm việc nhóm, tránh đè lên công việc của nhau.
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1750049430215/852687dd-5308-4749-a385-8497488bc8c0.png align="center")

## **1\. Local Version Control System (VCS cục bộ)**

* **Cách hoạt động:**
    
    * Chỉ lưu lịch sử thay đổi trên máy tính cá nhân của từng người dùng.
        
    * Mỗi khi bạn chỉnh sửa file, hệ thống sẽ lưu lại một bản sao (snapshot) của file đó vào một thư mục ẩn trên máy.
        
* **Ưu điểm:**
    
    * Đơn giản, dễ sử dụng cho cá nhân hoặc dự án nhỏ.
        
    * Không cần kết nối mạng, mọi thứ đều trên máy local.
        
* **Nhược điểm:**
    
    * **Không hỗ trợ làm việc nhóm:** Không thể chia sẻ thay đổi với người khác một cách tự động.
        
    * **Rủi ro mất dữ liệu:** Nếu máy tính bị hỏng hoặc mất, toàn bộ lịch sử dự án cũng mất theo.
        
    * **Khó kiểm soá**[**t**](https://www.linkedin.com/pulse/differentiate-between-centralized-distributed-version-control-ejv2c) **phiên bản khi nhiều người cùng làm việc.**
        

## **2\. Centralized Version Control System (CVCS – Hệ thống tập trung)**

* **Cách hoạt động:**
    
    * C[ó](https://www.linkedin.com/pulse/differentiate-between-centralized-distributed-version-control-ejv2c) một **máy chủ trung tâm** (central server) lưu trữ toàn bộ lịch sử và mã nguồn dự án.
        
    * Mọi thành viên trong nhóm phải kết nối tới máy chủ này để lấy code về, commit thay đổi và cập [n](https://www.linkedin.com/pulse/differentiate-between-centralized-distributed-version-control-ejv2c)hật phiên bản mới.
        
* **Ưu điểm:**
    
    * **Kiểm soát tập trung:** Dễ quản lý, kiểm soát quyền truy cập và lịch sử thay đổi.
        
    * **Phù hợp cho nhóm nhỏ hoặc môi trường kiểm soát chặt chẽ.**
        
* **Nhược điểm:**
    
    * **Phụ thuộc vào máy chủ:** Nếu server gặp sự cố hoặc mất mạng, mọi người không thể làm việc hoặc truy cập lịch sử dự án.
        
    * **Điểm yếu duy nhất:** Nếu server bị mất dữ liệu mà không có backup, toàn bộ lịch sử dự án có thể bị mất.
        
    * **Khó khăn khi làm việc offline:** Mọi thao tác đều cần kết nối tới server[,](https://about.gitlab.com/topics/version-control/what-is-centralized-version-control-system/) tốc độ chậm nếu mạng yếu.
        

## **3\. Distributed Version Control System (DVCS – Hệ thống phân tán)**

* **Cách hoạt** **động**[**:**](https://www.linkedin.com/pulse/differentiate-between-centralized-distributed-version-control-ejv2c)
    
    * **Mỗi người dùng có một bản sao đầy đủ** của toàn bộ repository (bao gồm cả lịch sử thay đổi) trên máy tính cá nhân.
        
    * Người dùng có thể commit, tạo nhánh[,](https://www.linkedin.com/pulse/differentiate-between-centralized-distributed-version-control-ejv2c) merge... hoàn toàn offline. Khi cần chia sẻ thay đổi, họ push/pull lên server chung (ví dụ GitHub).
        
* **Ưu điểm:**
    
    * **Làm việc offline:** Hầu hết thao tác không cần mạng, chỉ cần khi đồng bộ với nhóm.
        
    * **An toàn dữ liệu:** Nếu server bị hỏng, mọi người đều có bản sao đầy đủ [đ](https://www.tutorialspoint.com/difference-between-centralized-version-control-and-distributed-version-control)ể khôi phục dự án.
        
    * **Hỗ** **trợ** **branching, merging mạnh mẽ:** Phù hợp cho dự án lớn, nhóm đông người, open source.
        
    * **Tốc độ nhanh:** Vì thao tác chủ yếu trên má[y](https://blog.devart.com/centralized-vs-distributed-version-control.html) local.
        
* **Nhược điểm:**
    
    * **Khó học hơn:** Cần làm quen với nhiều khái niệm mới (branch, merge, pull, push...)[.](https://blog.devart.com/centralized-vs-distributed-version-control.html)
        
    * **Quản** **lý phức** **tạp** **hơn** nếu không có quy trình rõ ràng.
        

## **II. Git là gì?**

## 1\. **Bối cảnh ra đời (2005)**

* [**N**](https://builtin.com/articles/version-control-systems)**guyên nhân:**  
    Năm 2005, cộng đồng phá[t](https://about.gitlab.com/topics/version-control/what-is-centralized-version-control-system/) triển nhân Linux gặp phải mâu thuẫn lớn với công ty BitKeeper – đơn vị cung cấp công cụ quản lý mã nguồn mà nhóm Linux đang sử dụng. BitKeeper thay đổi chính sách cấp phép, dẫn đến việc nhóm phát triển Linux không còn quyền sử dụng miễn phí công cụ này nữa.
    
* **Vấn đề đặt ra:**[  
    ](https://about.gitlab.com/topics/version-control/what-is-centralized-version-control-system/)Dự án Linux là một dự án mã nguồn mở quy mô toàn cầu, cần một hệ thống quản lý phiên bản mạnh mẽ, miễn phí, không phụ thuộc vào bên thứ ba, và phải đáp ứng được tốc độ phát triển cực nhanh cũng như số lượng lập trình viên đón[g](https://blog.devart.com/centralized-vs-distributed-version-control.html) [g](https://builtin.com/articles/version-control-systems)óp rất lớn.
    

## 2\. **Người sáng lập**

* **Linus Torvalds** – cha đẻ của hệ điều hành Linux – đã trực tiếp bắt tay vào thiết kế và phát triển một hệ thốn[g](https://about.gitlab.com/topics/version-control/what-is-centralized-version-control-system/) quản lý phiên bản hoàn toàn mới, với mục tiêu giải [q](https://blog.devart.com/centralized-vs-distributed-version-control.html)u[y](https://builtin.com/articles/version-control-systems)ết triệt để các hạn chế của các hệ thống [c](https://www.tutorialspoint.com/difference-between-centralized-version-control-and-distributed-version-control)ũ và phù hợp với nhu cầu phát triển phần mềm mã nguồn mở quy mô lớn.
    

## 3\. **Mục tiêu thiết** **kế của Git**

* **Nhanh:**  
    Git phải xử lý các thao tác như commit, branch, merge[,](https://blog.devart.com/centralized-vs-distributed-version-control.html) và chuyển đổi giữa các phiên bản cực kỳ nhanh chóng, kể cả với dự án có hàng triệu dòng code.
    
* **Đơn giản:**  
    Cấu trúc dữ liệu và thao tác của Git phải dễ hiểu, dễ sử dụng, thuận tiện cho cả cá nhân lẫn n[h](https://blog.devart.com/centralized-vs-distributed-version-control.html)ó[m](https://builtin.com/articles/version-control-systems) lớn.
    
* **Dễ phân nhánh:**  
    Việc tạo, chuyển, gộp (merge) nhánh phải nhẹ nhàng, không tốn tài nguyên, khuyến khích phát triển song song và thử nghiệm tính năng mới mà không ảnh hưởng đến nhánh chính.
    
* **Làm việc phân tán:**  
    Mỗi lập trình viê[n](https://blog.devart.com/centralized-vs-distributed-version-control.html) [đ](https://builtin.com/articles/version-control-systems)ều có thể làm việc độc lập trên máy cá nhân với toàn bộ lịch sử dự án, chỉ cần kết nối mạng k[h](https://blog.devart.com/centralized-vs-distributed-version-control.html)i muốn đồng bộ hoặc chia sẻ thay đổi với cộng đồng.
    

## 4\. **Quá trình phát triển và phổ biến**

* Chỉ sau vài tháng phát triển, Git đã trở thành công cụ chính thức của dự án Linux, thay thế hoàn toàn BitKeeper.
    
* Nhờ các đặc tính vượt trội, Git nha[n](https://blog.devart.com/centralized-vs-distributed-version-control.html)h chóng được cộng đồng mã nguồn mở và các công ty công nghệ lớn trên toàn thế giới chấp nhận, sử dụng rộng rãi cho mọi loại dự án – từ nhỏ đến siêu lớn.
    

## 5\. **Ý nghĩa của sự ra đời Git**

* Git không chỉ là một phần mềm quản lý phiên bản, mà còn là một bước ngoặt lớn trong việc phát triển phần mềm hiện đại, đặc biệt là các dự án mã nguồn mở, nơi cộng tác phân tán, kiểm soát lịch sử và bảo vệ dữ liệu là tối quan trọng.
    

## **Các khái niệm cơ bản trong Git:**

* **Repository (repo):** Thư mục chứa toàn bộ mã nguồn và lịch sử thay đổi của dự án.
    
* **Commit:** Lưu lại một “ảnh chụp” trạng thái dự án tại thời điểm đó.
    
* **Branch:** Nhánh phát triển song song, giúp thử nghiệm tính năng mới mà không ảnh hưởng đến mã nguồn chính.
    
* **Merge:** Kết hợp thay đổi từ các nhánh khác nhau.
    
* **Pull:** Lấy về các thay đổi mới nhất từ repo trên mạng về máy cá nhân.
    
* **Push:** Đẩy các thay đổi từ máy cá nhân lên repo trên mạng.
    

## Nguyên lý hoạt động của Git

## **1\. Snapshot thay vì Diff**

* **Khác biệt với VCS cũ:**  
    Các hệ thống quản lý phiên bản truyền thống (như SVN, CVS) chỉ lưu lại các thay đổi (diff) giữa các phiên bản file. Điều này khiến việc phục hồi hoặc xem lại toàn bộ trạng thái dự án ở một thời điểm cụ thể trở nên phức tạp và đôi khi chậm.
    
* **Git lưu “bản chụp” toàn bộ dự án mỗi khi commit:**  
    Thay vì chỉ lưu phần thay đổi, Git sẽ lưu lại một snapshot (ảnh chụp) của toàn bộ dự án ở thời điểm commit. Điều này giúp việc phục hồi, so sánh và quản lý lịch sử dự án trở nên đơn giản, nhanh chóng hơn.
    
* **Tiết kiệm dung lượng:**  
    Nếu một file không thay đổi giữa các lần commit, Git không lưu lại file đó lần nữa mà chỉ tạo liên kết đến bản chụp cũ. Nhờ vậy, Git vừa tiết kiệm dung lượng, vừa giữ được tốc độ xử lý cao.
    

## **2\. Toàn vẹn dữ liệu với SHA-1**

* **Bảo vệ dữ liệu bằng hàm băm SHA-1:**  
    Mỗi đối tượng (file, commit, thư mục...) trong Git đều được gắn một mã định danh duy nhất dài 40 ký tự, được tạo ra bằng thuật toán băm SHA-1. Điều này giúp đảm bảo dữ liệu không bị thay đổi mà không bị phát hiện.
    
* **Thay đổi nội dung, thay đổi mã hash:**  
    Khi nội dung file thay đổi, mã hash cũng thay đổi hoàn toàn. Nhờ vậy, bất kỳ sự thay đổi nào dù nhỏ nhất cũng được Git phát hiện, giúp bảo vệ dữ liệu khỏi bị hỏng hoặc bị chỉnh sửa không hợp lệ.
    

## **3\. Nguyên lý “Offline-first”**

* **Làm việc không cần mạng:**  
    Git cho phép bạn thực hiện hầu hết các thao tác (commit, tạo nhánh, gộp nhánh, xem lịch sử...) ngay trên máy tính cá nhân, không cần kết nối Internet.
    
* **Chỉ cần mạng khi chia sẻ:**  
    Bạn chỉ cần kết nối Internet khi muốn chia sẻ code với người khác (push lên hoặc pull về từ remote repository như GitHub, GitLab...).
    
* **Tăng hiệu suất và linh hoạt:**  
    Nhờ nguyên lý này, Git rất phù hợp cho dự án lớn, nhóm đông người, hoặc khi làm việc ở môi trường mạng không ổn định.
    

## **Vì sao nên dùng Git?**

* Theo dõi lịch sử dự án chi tiết.
    
* Hỗ trợ làm việc nhóm linh hoạt.
    
* Dễ dàng thử nghiệm, phát triển tính năng mới nhờ branching.
    
* Tốc độ xử lý nhanh, hiệu quả ngay cả với dự án lớn.
    

## **III. GitHub là gì?**

GitHub là nền tảng lưu trữ trực tuyến cho các repository Git, đồng thời cung cấp các công cụ cộng tác, quản lý dự án, theo dõi lỗi, review code, và nhiều tính năng mở rộng khác. GitHub giúp bạn chia sẻ, hợp tác và phát triển dự án với cộng đồng lập trình viên toàn cầu.

## **So sánh Git và GitHub**

| **Tính năng** | **Git (Local)** | **GitHub (Online)** |
| --- | --- | --- |
| Mục đích | Quản lý phiên bản mã nguồn trên máy cá nhân | Lưu trữ repo Git trực tuyến, hỗ trợ cộng tác |
| Tạo bởi | Linus Torvalds | GitHub Inc. |
| Cộng tác | Qua repo chia sẻ, cần thiết lập thủ công | Dễ dàng qua pull request, issue, project management |
| Theo dõi lỗi | Không tích hợp | Có hệ thống issue tracking mạnh mẽ |
| Quản lý dự án | Không có | Có Kanban board, milestone, wiki |
| Tính năng mở rộng | Branching, merging, tagging | Pull request, review code, thống kê, marketplace |

## **IV. Quy trình làm việc cơ bản với Git & GitHub**

## **Cài đặt:**

* Linux: `sudo apt install git`
    
* macOS: `xcode-select --install` hoặc tải từ [git-scm.com](http://git-scm.com)
    
* Windows: tải từ [git-scm.com](http://git-scm.com) hoặc `choco install git`
    
    **Cấu hình cơ bản:**
    
    ```bash
    bashgit config --global user.name "Tên Của Bạn"
    git config --global user.email "email@example.com"
    ```
    
    **Alias hữu ích:**
    
    ```bash
    bashgit config --global alias.st status
    git config --global alias.co checkout
    git config --global alias.br branch
    git config --global alias.cm "commit -m"
    ```
    

## Quy trình làm việc cơ bản với Git

* **Khởi tạo repository:**
    
    ```bash
    bashmkdir <ten_du_an>
    cd <ten_du_an>
    git init
    ```
    
* **Sao chép repository từ xa:**
    
    ```bash
    bashgit clone https://github.com/username/repository.git
    ```
    
* **Theo dõi và lưu trữ thay đổi:**
    
    * `git status`, `git add`, `git commit -m "message"`
        
    * Sử dụng `.gitignore` để loại trừ file/thư mục không cần thiết
        
* **Xem lịch sử:**
    
    * `git log`, `git log --oneline --graph --all`
        
* **Hoàn tác thay đổi:**
    
    * `git restore`, `git revert`, `git commit --amend`, `git stash`
        

## Làm việc với remote repository

* **Thêm remote:**
    
    ```bash
    bashgit remote add origin https://github.com/username/repository.git
    ```
    
* **Đồng bộ hóa:**
    
    * `git push origin main`
        
    * `git pull origin main`
        
* **Tagging:**
    
    * Annotated tag: `git tag -a v1.0 -m "Version 1.0"`
        
    * Lightweight tag: `git tag v1.0-beta`
        
    * Đẩy tag: `git push origin v1.0` hoặc `git push origin --tags`
        

## Quản lý nhánh và lịch sử

* **Tạo/chuyển/gộp nhánh:**
    
    ```bash
    bashgit checkout -b feature/ten-tinh-nang
    git merge feature/ten-tinh-nang
    ```
    
* **Giải quyết xung đột:**
    
    * Chỉnh sửa file, `git add .`, `git commit`
        
* **Quản lý nhánh:**
    
    * Liệt kê: `git branch`, `git branch -a`
        
    * Xóa: `git branch -d ten-nhanh`
        
    * Đổi tên: `git branch -m ten-moi`
        
* **Rebase:**
    
    * `git rebase main`
        
    * `git rebase -i HEAD~3`
        

## Cộng tác qua GitHub

* **Thiết lập tài khoản & bảo mật:**
    
    * Đăng ký, xác thực email, tạo SSH key, bật 2FA
        
* **Quy trình Fork & Pull Request:**
    
    1. Fork repository
        
    2. Clone về máy
        
    3. Tạo nhánh mới, commit, push
        
    4. Tạo Pull Request trên GitHub
        
    5. Thảo luận, cập nhật, merge
        
* **Quản lý repository:**
    
    * Tạo README.md, CONTRIBUTING.md, CODE\_OF\_CONDUCT.md
        
    * Thiết lập branch protection, quản lý teams/organization
        

## Tùy chỉnh & mở rộng Git

* **Cấu hình nâng cao:**
    
    * Đổi nhánh mặc định: `git config --global init.defaultBranch main`
        
    * Mẫu commit message, công cụ merge/diff, proxy, credential helper
        
* **Git Attributes:**
    
    * Quản lý line ending, file binary, merge strategy, filter clean/smudge
        
* **Git Hooks:**
    
    * Tự động hóa kiểm tra code, format, CI/CD trước/sau commit/push
        
* **Alias & Scripts:**
    
    * Tạo lệnh tắt, hàm shell cho workflow cá nhân/team
        

## **V. Kết luận**

Git và GitHub là bộ đôi không thể thiếu với bất kỳ ai làm việc với code. Git giúp bạn kiểm soát mọi thay đổi, còn GitHub mở rộng khả năng cộng tác, quản lý dự án và chia sẻ với cộng đồng. Dù bạn là người mới hay đã có kinh nghiệm, hãy bắt đầu sử dụng Git & GitHub để nâng tầm kỹ năng lập trình và làm việc chuyên nghiệp hơn.